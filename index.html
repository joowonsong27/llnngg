<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LNG OF LEGEND</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Malgun Gothic', sans-serif;
            background: #1a1a2e;
            color: #eee;
            overflow: hidden;
        }

        /* ê³µí†µ í™”ë©´ ìŠ¤íƒ€ì¼ */
        .screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .screen.active {
            display: flex;
        }

        .box {
            background: #16213e;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            text-align: center;
        }

        h1 {
            color: #00fff5;
            margin-bottom: 30px;
            font-size: 32px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        h2 {
            color: #00fff5;
            margin-bottom: 20px;
            font-size: 24px;
        }

        input {
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            border: 2px solid #00fff5;
            background: #0f3460;
            color: #fff;
            border-radius: 8px;
            font-size: 16px;
        }

        input:focus {
            outline: none;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }

        button {
            padding: 15px 30px;
            margin: 10px;
            background: #00fff5;
            color: #16213e;
            border: none;
            border-radius: 8px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        button:hover:not(:disabled) {
            background: #00d4cc;
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.7);
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: scale(1);
        }

        /* ë‹‰ë„¤ì„ í™”ë©´ */
        #nicknameScreen .box {
            min-width: 400px;
        }

        /* ì§ì—… ì„ íƒ í™”ë©´ */
        #classScreen .box {
            min-width: 600px;
            max-width: 700px;
            padding: 30px;
        }

        .class-swiper {
            position: relative;
            width: 100%;
            height: 480px;
            overflow: hidden;
            margin: 20px 0;
        }

        .class-slider {
            display: flex;
            transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            height: 100%;
        }

        .class-slide {
            min-width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 0 40px;
        }

        .class-card {
            background: linear-gradient(135deg, #0f3460 0%, #16213e 100%);
            border: 3px solid #00fff5;
            border-radius: 20px;
            padding: 40px;
            width: 100%;
            max-width: 450px;
            box-shadow: 0 10px 40px rgba(0, 255, 255, 0.3);
        }

        .class-card h3 {
            font-size: 32px;
            margin-bottom: 10px;
            color: #00fff5;
        }

        .class-card .class-icon {
            font-size: 64px;
            margin: 15px 0;
        }

        .class-card .description {
            color: #aaa;
            margin: 15px 0;
            font-size: 16px;
        }

        .class-card .stats {
            text-align: left;
            font-size: 15px;
            margin-top: 20px;
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
        }

        .class-card .stats div {
            margin: 8px 0;
            padding: 8px 12px;
            background: rgba(0, 255, 245, 0.1);
            border-radius: 6px;
            border-left: 3px solid #00fff5;
        }

        .swiper-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 50px;
            height: 50px;
            background: rgba(0, 255, 245, 0.2);
            border: 2px solid #00fff5;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 10;
            font-size: 24px;
            color: #00fff5;
            user-select: none;
        }

        .swiper-nav:hover {
            background: rgba(0, 255, 245, 0.4);
            transform: translateY(-50%) scale(1.1);
        }

        .swiper-nav.prev {
            left: 10px;
        }

        .swiper-nav.next {
            right: 10px;
        }

        .swiper-dots {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }

        .swiper-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            cursor: pointer;
            transition: all 0.3s;
        }

        .swiper-dot.active {
            background: #00fff5;
            width: 30px;
            border-radius: 6px;
        }

        /* ë°© ì„ íƒ í™”ë©´ */
        #roomScreen .box {
            min-width: 480px;
            max-width: 560px;
        }

        .room-list {
            max-height: 320px;
            overflow-y: auto;
            margin: 16px 0;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .room-item {
            background: #0f3460;
            border: 2px solid rgba(0,255,245,0.3);
            border-radius: 8px;
            padding: 16px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .room-item:hover {
            border-color: #00fff5;
            background: rgba(0,255,245,0.1);
            transform: translateX(4px);
            box-shadow: 0 4px 12px rgba(0, 255, 245, 0.2);
        }

        .room-item .room-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .room-item .room-host {
            font-weight: bold;
            font-size: 16px;
            color: #00fff5;
        }

        .room-item .room-count {
            font-size: 13px;
            color: #aaa;
        }
        .room-empty {
            color: #555;
            font-size: 14px;
            text-align: center;
            padding: 30px 0;
        }

        .room-create-btn {
            width: 100%;
            margin: 0;
            padding: 14px;
            font-size: 16px;
            background: #16213e;
            color: #00fff5;
            border: 2px solid #00fff5;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            letter-spacing: 1px;
        }

        .room-create-btn:hover {
            background: #00fff5;
            color: #16213e;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           ëŒ€ê¸°ì‹¤ â€” 3ë¶„í•  í’€ìŠ¤í¬ë¦°
           ì¢Œ: ìŠ¤í   |  ì¤‘: ì§ì—…ì„ íƒ+ì •ë³´  |  ìš°: ëª…ë‹¨
        â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #lobbyScreen { align-items: stretch; background: rgba(0,0,0,0.97); }
        #lobbyScreen > .box {
            width: 100vw; max-width: 100vw; height: 100vh; max-height: 100vh;
            border-radius: 0; padding: 16px 44px 12px;
            display: flex; flex-direction: column; overflow: hidden;
            box-shadow: none; text-align: left;
        }

        /* í—¤ë” */
        #lobbyHeaderBar {
            display: flex; align-items: center; justify-content: space-between;
            flex-shrink: 0; margin-bottom: 12px; padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.07);
        }
        #lobbyHeaderBar #lobbyTitle { margin: 0; font-size: 20px; letter-spacing: 1px; }
        #lobbyHeaderMeta { display: flex; align-items: center; gap: 18px; font-size: 13px; color: #666; }
        #lobbyHeaderMeta strong { color: #ccc; }
        #hostIndicator { color: #ffd700; font-size: 13px; font-weight: bold; display: none; }

        /* â”€â”€ 3ë¶„í• : ìŠ¤í (260px) | ì§ì—…(minmax 360px, 1fr) | ëª…ë‹¨(340px) â”€â”€ */
        #lobbyGrid {
            display: grid;
            grid-template-columns: 260px minmax(360px, 520px) 340px;
            justify-content: center;   /* ì „ì²´ë¥¼ ì¤‘ì•™ ì •ë ¬ â†’ ë‚¨ì€ ê³µê°„ì€ ì–‘ìª½ ìë™ ì—¬ë°± */
            gap: 14px;
            flex: 1;
            min-height: 0;
        }

        /* ê³µí†µ íŒ¨ë„ */
        .lby-panel {
            border-radius: 14px; display: flex; flex-direction: column;
            overflow: hidden; min-height: 0;
        }
        .lby-panel-head {
            font-size: 10px; font-weight: bold; letter-spacing: 2px;
            text-transform: uppercase; padding: 9px 14px 7px; flex-shrink: 0;
            border-bottom: 1px solid rgba(255,255,255,0.06);
        }

        /* â”€â”€ ì¢Œ: ìŠ¤í  â”€â”€ */
        #lobbyLeft {
            background: rgba(255,170,0,0.04);
            border: 1.5px solid rgba(255,170,0,0.28);
        }
        #lobbyLeft .lby-panel-head { color: #ffaa00; }

        /* ìŠ¤í  ìŠ¤ì™€ì´í¼ */
        #spellSwiper  { position: relative; overflow: hidden; flex: 1; min-height: 0; }
        #spellSlider  { display: flex; height: 100%; transition: transform .35s cubic-bezier(.25,.46,.45,.94); }
        .lby-spell-slide {
            min-width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            padding: 10px 48px; /* í™”ì‚´í‘œ(32px) í”¼í•˜ëŠ” íŒ¨ë”© */
        }
        .lby-spell-card {
            width: 100%; text-align: center;
            display: flex; flex-direction: column; align-items: center; gap: 8px;
            cursor: pointer; padding: 16px 10px; border-radius: 12px;
            border: 2px solid transparent; transition: all .22s;
            background: rgba(255,170,0,0.05);
        }
        .lby-spell-card:hover   { background: rgba(255,170,0,0.11); border-color: rgba(255,170,0,0.35); }
        .lby-spell-card.selected {
            background: rgba(255,170,0,0.15); border-color: #ffaa00;
            box-shadow: 0 0 22px rgba(255,170,0,0.25);
        }
        .lby-spell-card .sc-icon { font-size: 50px; line-height: 1; filter: drop-shadow(0 0 12px rgba(255,170,0,.5)); }
        .lby-spell-card .sc-name { font-size: 20px; font-weight: bold; color: #ffaa00; }
        .lby-spell-card .sc-cd   { font-size: 11px; font-weight: bold; color: #ff9900; background: rgba(255,153,0,0.12); border: 1px solid rgba(255,153,0,0.25); border-radius: 20px; padding: 2px 10px; }
        .lby-spell-card .sc-desc { font-size: 11.5px; color: #999; line-height: 1.6; max-width: 185px; margin-top: 4px; }

        /* ìŠ¤í  í™”ì‚´í‘œ â€” ì£¼í™©, ì‘ê²Œ */
        #lobbyLeft .swiper-nav {
            background: rgba(255,170,0,0.15); border-color: rgba(255,170,0,0.4);
            color: #ffaa00; width: 32px; height: 32px; font-size: 17px;
        }
        #lobbyLeft .swiper-nav:hover { background: rgba(255,170,0,0.3); }

        #spellDots { display: flex; justify-content: center; gap: 7px; padding: 7px 0 9px; flex-shrink: 0; }
        #spellDots .swiper-dot.active { background: #ffaa00; }

        /* â”€â”€ ì¤‘ì•™: ì§ì—… ì„ íƒ + ì •ë³´ í†µí•© â”€â”€ */
        #lobbyCenter {
            background: rgba(0,255,245,0.03);
            border: 1.5px solid rgba(0,255,245,0.2);
        }
        #lobbyCenter .lby-panel-head { color: #00fff5; }

        /* ì§ì—… ìŠ¤ì™€ì´í¼ */
        #lobbyClassSwiper { position: relative; overflow: hidden; height: 230px; flex-shrink: 0; }
        #lobbyClassSlider { display: flex; height: 100%; transition: transform .38s cubic-bezier(.25,.46,.45,.94); }
        .lby-class-slide {
            min-width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            padding: 8px 52px; /* í™”ì‚´í‘œ(34px) í”¼í•˜ëŠ” íŒ¨ë”© */
        }
        .lby-class-card {
            width: 100%; text-align: center;
            display: flex; flex-direction: column; align-items: center; gap: 4px;
        }
        .lby-class-card .lcc-icon { font-size: 64px; line-height: 1; filter: drop-shadow(0 0 16px rgba(0,255,245,.45)); }
        .lby-class-card .lcc-name { font-size: 24px; font-weight: bold; color: #00fff5; text-shadow: 0 0 10px rgba(0,255,245,.4); }

        /* ì§ì—… í™”ì‚´í‘œ */
        #lobbyCenter .swiper-nav { width: 34px; height: 34px; font-size: 18px; }

        #lobbyClassDots { display: flex; justify-content: center; gap: 7px; padding: 6px 0 4px; flex-shrink: 0; }

        /* ì§ì—… ì •ë³´ ì˜ì—­ (ìŠ¬ë¼ì´ë” ì•„ë˜ ìŠ¤í¬ë¡¤) */
        #lobbyClassInfo { flex: 1; overflow-y: auto; border-top: 1px solid rgba(255,255,255,0.06); }

        /* â”€â”€ ìš°: í”Œë ˆì´ì–´ ëª…ë‹¨ â”€â”€ */
        #lobbyRight {
            background: rgba(255,255,255,0.02);
            border: 1.5px solid rgba(255,255,255,0.09);
        }
        #lobbyRight .lby-panel-head { color: #777; letter-spacing: 1.5px; }

        .player-list { flex: 1; overflow-y: auto; padding: 6px 13px 10px; }

        .lobby-player {
            background: rgba(15,52,96,0.55); padding: 10px 12px; margin: 6px 0;
            border-radius: 10px; display: flex; justify-content: space-between;
            align-items: center; border: 1.5px solid transparent; gap: 6px; transition: border-color .2s;
        }
        .lobby-player.ready  { border-color: rgba(0,220,0,.5); background: rgba(0,60,0,.22); }
        .lobby-player.host   { border-color: rgba(255,215,0,.4); }

        .lobby-player-info { display: flex; flex-direction: column; gap: 3px; flex: 1; min-width: 0; }
        .lp-name-row {
            display: flex; align-items: center; gap: 6px;
            font-size: 13px; font-weight: bold;
        }
        .lp-name-row .player-color {
            width: 11px; height: 11px; border-radius: 50%;
            border: 1.5px solid rgba(255,255,255,0.4); flex-shrink: 0;
        }
        .lp-badge-row { display: flex; gap: 5px; flex-wrap: wrap; align-items: center; }
        .lobby-player-class {
            background: rgba(0,255,245,0.1); color: #00fff5;
            padding: 2px 8px; border-radius: 4px; font-size: 11px; white-space: nowrap;
        }
        .lobby-player-spell-badge {
            background: rgba(255,170,0,0.1); color: #ffaa00;
            padding: 2px 8px; border-radius: 4px; font-size: 11px; white-space: nowrap;
        }
        .lobby-player-status {
            padding: 3px 10px; border-radius: 5px; font-size: 10px;
            font-weight: bold; white-space: nowrap; flex-shrink: 0;
        }
        .lobby-player-status.ready   { background: #00c853; color: #000; }
        .lobby-player-status.waiting { background: #bf360c; color: #fff; }

        /* í•˜ë‹¨ ë²„íŠ¼ */
        .lobby-buttons {
            display: flex; gap: 12px; justify-content: center;
            margin-top: 12px; flex-shrink: 0;
        }
        .lobby-buttons button { padding: 10px 26px; font-size: 15px; margin: 0; }

        /* ê²Œì„ ëŒ€ê¸° í™”ë©´ */
        #waitingScreen .box {
            min-width: 500px;
        }

        .waiting-message {
            font-size: 20px;
            margin: 20px 0;
            color: #00fff5;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #0f3460;
            border-top-color: #00fff5;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 30px auto;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* ê²Œì„ í™”ë©´ */
        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: none;
            justify-content: center;
            align-items: center;
        }

        #gameCanvas {
            background: #0f3460;
            border: 3px solid #16213e;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
        }

        #info {
            display: none;
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(22, 33, 62, 0.9);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #00fff5;
            min-width: 250px;
        }

        #info h3 {
            color: #00fff5;
            margin-bottom: 15px;
        }

        #info p {
            margin: 8px 0;
            font-size: 14px;
        }

        #playerList {
            display: none;
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(22, 33, 62, 0.9);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #00fff5;
            min-width: 200px;
            max-height: 400px;
            overflow-y: auto;
        }

        #playerList h3 {
            color: #00fff5;
            margin-bottom: 15px;
        }

        .player-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(0, 255, 245, 0.1);
            border-radius: 5px;
            display: flex;
            align-items: center;
        }

        .player-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid #fff;
        }

        #controls {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(22, 33, 62, 0.9);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #00fff5;
        }

        #controls p {
            margin: 5px 0;
            font-size: 14px;
        }

        .error {
            color: #ff4757;
            margin-top: 10px;
            font-size: 14px;
        }

        /* ìŠ¤í  ì¹´ë“œ */
        .spell-card {
            width: 110px;
            padding: 14px 10px;
            background: #0f3460;
            border: 2px solid rgba(255,170,0,0.3);
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.25s;
            text-align: center;
            user-select: none;
        }
        .spell-card:hover {
            border-color: #ffaa00;
            background: rgba(255,170,0,0.1);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(255,170,0,0.3);
        }
        .spell-card.selected {
            border-color: #ffaa00;
            background: rgba(255,170,0,0.2);
            box-shadow: 0 0 20px rgba(255,170,0,0.5);
        }
        .spell-card .spell-icon { font-size: 32px; margin-bottom: 6px; }
        .spell-card .spell-name { font-size: 13px; font-weight: bold; color: #ffaa00; margin-bottom: 4px; }
        .spell-card .spell-cd   { font-size: 11px; color: #aaa; }
        .spell-card .spell-desc { font-size: 10px; color: #888; margin-top: 4px; line-height: 1.3; }

        /* ì§ì—… íˆ´íŒ íŒ¨ë„ */
        .tooltip-section-title {
            font-size: 10px;
            font-weight: bold;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: #555;
            margin: 14px 0 5px 0;
        }
        .tooltip-section-title:first-child { margin-top: 0; }

        /* ìŠ¤í‚¬ í—¤ë” (ì´ë¦„ + ì¿¨íƒ€ì„ ë¶„ë¦¬) */
        .tooltip-skill-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
            gap: 8px;
        }
        .tooltip-skill-name {
            font-size: 14px;
            font-weight: bold;
            color: #fff;
        }
        .tooltip-skill-cd {
            font-size: 11px;
            font-weight: bold;
            color: #ff9900;
            background: rgba(255,153,0,0.12);
            border: 1px solid rgba(255,153,0,0.3);
            border-radius: 20px;
            padding: 2px 10px;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .tooltip-ability {
            background: rgba(0,255,245,0.04);
            border: 1px solid rgba(0,255,245,0.1);
            border-left: 3px solid #00fff5;
            border-radius: 0 8px 8px 0;
            padding: 10px 14px;
            margin-bottom: 8px;
            font-size: 12.5px;
            line-height: 1.75;
            color: #bbc;
        }
        .tooltip-ability.skill-block {
            border-left-color: #ff9900;
            border-color: rgba(255,153,0,0.1);
            background: rgba(255,153,0,0.04);
        }
        .tooltip-ability b { color: #fff; }

        /* ë²„í”„/ë””ë²„í”„/ë°ë¯¸ì§€ ì¸ë¼ì¸ íƒœê·¸ */
        .tt-buff {
            display: inline-block;
            background: rgba(0,255,120,0.15);
            color: #00ff88;
            border: 1px solid rgba(0,255,120,0.3);
            border-radius: 4px;
            padding: 1px 7px;
            font-size: 11.5px;
            font-weight: bold;
            line-height: 1.5;
            white-space: nowrap;
        }
        .tt-debuff {
            display: inline-block;
            background: rgba(255,60,60,0.15);
            color: #ff6666;
            border: 1px solid rgba(255,60,60,0.3);
            border-radius: 4px;
            padding: 1px 7px;
            font-size: 11.5px;
            font-weight: bold;
            line-height: 1.5;
            white-space: nowrap;
        }
        .tt-dmg {
            display: inline-block;
            background: rgba(255,200,0,0.15);
            color: #ffd700;
            border: 1px solid rgba(255,200,0,0.3);
            border-radius: 4px;
            padding: 1px 7px;
            font-size: 11.5px;
            font-weight: bold;
            line-height: 1.5;
            white-space: nowrap;
        }
        .tt-neut {
            display: inline-block;
            background: rgba(180,180,255,0.12);
            color: #aaaaff;
            border: 1px solid rgba(180,180,255,0.22);
            border-radius: 4px;
            padding: 1px 7px;
            font-size: 11.5px;
            font-weight: bold;
            line-height: 1.5;
            white-space: nowrap;
        }

        .tooltip-coeff-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 6px;
        }
        .tooltip-coeff-badge {
            font-size: 12px;
            font-weight: bold;
            background: rgba(0,255,245,0.15);
            color: #00fff5;
            border-radius: 6px;
            padding: 2px 8px;
            white-space: nowrap;
        }
        .tooltip-coeff-badge.fixed {
            background: rgba(255,153,0,0.15);
            color: #ff9900;
        }
        .tooltip-coeff-label {
            font-size: 12px;
            color: #aaa;
        }
        .tooltip-stat-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-top: 6px;
        }
        .tooltip-stat-item {
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
            padding: 6px 10px;
            font-size: 12px;
            color: #ccc;
        }
        .tooltip-stat-item span { color: #00fff5; font-weight: bold; }

        .loading {
            color: #00fff5;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <!-- ë‹‰ë„¤ì„ ì…ë ¥ í™”ë©´ -->
    <div id="nicknameScreen" class="screen active">
        <div class="box" style="position: relative;">
            <h1>âš”ï¸ LNG OF LEGEND</h1>
            <p style="color: #aaa; margin-bottom: 20px;">ë‹‰ë„¤ì„ì„ ì…ë ¥í•˜ì„¸ìš”</p>
            <input type="text" id="nicknameInput" placeholder="ë‹‰ë„¤ì„ ì…ë ¥ (ìµœëŒ€ 12ì)" maxlength="12">
            <button id="nicknameNextBtn">ë‹¤ìŒ</button>
            <p class="error" id="nicknameError"></p>
            <span style="position: absolute; bottom: 10px; right: 14px; font-size: 11px; color: #555; user-select: none;">v0.0.4</span>
        </div>
    </div>

    <!-- ì§ì—… ì„ íƒ í™”ë©´ -->
    <div id="classScreen" class="screen">
        <div class="box" style="display:flex; gap:24px; align-items:flex-start; max-width:1000px; min-width:900px; padding:32px;">
            <!-- ì¢Œ: ìŠ¬ë¼ì´ë” -->
            <div style="flex:0 0 420px;">
                <h1 style="margin-bottom:10px;">âš”ï¸ ì§ì—… ì„ íƒ</h1>
                <p style="color: #aaa; margin-bottom: 10px; font-size:13px;">ì¢Œìš°ë¡œ ë„˜ê²¨ ì§ì—…ì„ ì„ íƒí•˜ì„¸ìš”</p>
                <div class="class-swiper">
                    <div class="class-slider" id="classSlider"></div>
                    <div class="swiper-nav prev" id="swiperPrev">â€¹</div>
                    <div class="swiper-nav next" id="swiperNext">â€º</div>
                </div>
                <div class="swiper-dots" id="swiperDots"></div>
                <button id="classSelectBtn" disabled style="margin-top:12px; width:100%;">ì„ íƒ ì™„ë£Œ</button>
                <p class="error" id="classError"></p>
            </div>
            <!-- ìš°: íˆ´íŒ íŒ¨ë„ -->
            <div id="classTooltipPanel" style="flex:1; background:rgba(0,0,0,0.4); border:2px solid rgba(0,255,245,0.25); border-radius:14px; padding:22px; min-height:460px; text-align:left;">
                <div id="classTooltipContent" style="color:#eee; font-size:14px; line-height:1.7;">
                    <!-- JSë¡œ ì±„ì›Œì§ -->
                </div>
            </div>
        </div>
    </div>

    <!-- ë°© ì„ íƒ í™”ë©´ -->
    <div id="roomScreen" class="screen">
        <div class="box">
            <h1>ğŸ  ë°© ì„ íƒ</h1>
            <p style="color:#aaa; margin-bottom:4px; font-size:14px;">ë°©ì„ ì„ íƒí•˜ê±°ë‚˜ ìƒˆë¡œ ë§Œë“œì„¸ìš”</p>
            <div class="room-list" id="roomList">
                <div class="room-empty">ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</div>
            </div>
            <button class="room-create-btn" id="createRoomBtn">+ ìƒˆ ë°© ë§Œë“¤ê¸°</button>
            <button id="roomBackBtn" style="width:100%; margin: 8px 0; padding:12px; background:#444; color:#fff; border:none; border-radius:8px; font-size:15px; font-weight:bold; cursor:pointer;">â† ë‹‰ë„¤ì„ìœ¼ë¡œ ëŒì•„ê°€ê¸°</button>
            <p class="error" id="roomError" style="margin-top:10px;"></p>
        </div>
    </div>

    <!-- ëŒ€ê¸°ì‹¤ í™”ë©´ -->
    <div id="lobbyScreen" class="screen">
        <div class="box">

            <!-- í—¤ë” -->
            <div id="lobbyHeaderBar">
                <h1 id="lobbyTitle">ğŸ  ëŒ€ê¸°ì‹¤</h1>
                <div id="lobbyHeaderMeta">
                    <span>ì ‘ì† ì¸ì›: <strong id="lobbyPlayerCount">0</strong>ëª…</span>
                    <span id="hostIndicator">ğŸ‘‘ ë°©ì¥</span>
                </div>
            </div>

            <!-- 3ë¶„í•  ê·¸ë¦¬ë“œ: ìŠ¤í (ì¢Œ) | ì§ì—…(ì¤‘ì•™) | ëª…ë‹¨(ìš°) -->
            <div id="lobbyGrid">

                <!-- ì¢Œ: ìŠ¤í  ì„ íƒ -->
                <div id="lobbyLeft" class="lby-panel">
                    <div class="lby-panel-head">âœ¨ ìŠ¤í  ì„ íƒ <span style="font-weight:normal;color:#555;letter-spacing:0;font-size:9px;">SHIFT</span></div>
                    <div id="spellSwiper">
                        <div id="spellSlider"></div>
                        <div class="swiper-nav prev" id="spellSwiperPrev">â€¹</div>
                        <div class="swiper-nav next" id="spellSwiperNext">â€º</div>
                    </div>
                    <div id="spellDots" class="swiper-dots"></div>
                </div>

                <!-- ì¤‘ì•™: ì§ì—… ì„ íƒ + ì •ë³´ í†µí•© -->
                <div id="lobbyCenter" class="lby-panel">
                    <div class="lby-panel-head">âš” ì§ì—… ì„ íƒ</div>
                    <div id="lobbyClassSwiper">
                        <div id="lobbyClassSlider"></div>
                        <div class="swiper-nav prev" id="lobbySwiperPrev">â€¹</div>
                        <div class="swiper-nav next" id="lobbySwiperNext">â€º</div>
                    </div>
                    <div id="lobbyClassDots" class="swiper-dots"></div>
                    <p class="error" id="lobbyClassError" style="text-align:center;padding:0 10px;font-size:12px;"></p>
                    <div id="lobbyClassInfo"></div>
                </div>

                <!-- ìš°: í”Œë ˆì´ì–´ ëª…ë‹¨ -->
                <div id="lobbyRight" class="lby-panel">
                    <div class="lby-panel-head">ğŸ‘¥ í”Œë ˆì´ì–´ ëª…ë‹¨</div>
                    <div class="player-list" id="lobbyPlayerList"></div>
                </div>

            </div>

            <!-- í•˜ë‹¨ ë²„íŠ¼ -->
            <div class="lobby-buttons">
                <button id="lobbyBackBtn" style="background:#2a2a2a;color:#888;font-size:14px;padding:10px 18px;">â† ë°© ëª©ë¡</button>
                <button id="readyBtn">ì¤€ë¹„ ì™„ë£Œ</button>
                <button id="startBtn" style="display:none;" disabled>ê²Œì„ ì‹œì‘</button>
                <button id="practiceBtn" style="display:none;background:#9b59b6;">ì—°ìŠµ ëª¨ë“œ</button>
            </div>
            <p class="error" id="lobbyError" style="text-align:center;margin-top:4px;"></p>

        </div>
    </div>

    <!-- ê²Œì„ í™”ë©´ -->
    <div id="gameContainer">
        <canvas id="gameCanvas" width="1200" height="800"></canvas>
    </div>

    <div id="info">
        <h3>ğŸ“Š ê²Œì„ ì •ë³´</h3>
        <p>ë‹‰ë„¤ì„: <span id="myNickname">-</span></p>
        <p>ì§ì—…: <span id="myClass">-</span></p>
        <p>ì²´ë ¥: <span id="myHealth">-</span></p>
        <p>ì ‘ì† ì¸ì›: <span id="playerCount">0</span>ëª…</p>
    </div>

    <div id="playerList">
        <h3>ğŸ‘¥ í”Œë ˆì´ì–´</h3>
        <div id="playerListContent"></div>
    </div>

    <div id="controls">
        <h3 style="color: #00fff5; margin-bottom: 10px;">&#127918; ì¡°ì‘ë²•</h3>
        <p>&#9000; WASD: ì´ë™</p>
        <p>&#128432; ì¢Œí´ë¦­: ê¸°ë³¸ ê³µê²©</p>
        <p>&#128432; ìš°í´ë¦­: <span id="skillActionLabel">ìŠ¤í‚¬</span></p>
        <p>Shift: <span id="spellActionLabel">ìŠ¤í </span></p>
        <p style="color: #ff4444;">R 3ì´ˆ: ê°•ì œ ì¢…ë£Œ</p>
        <hr style="border-color: #00fff5; margin: 10px 0;">
        <h3 style="color: #00fff5; margin-bottom: 8px;">ì¿¨íƒ€ì„</h3>
        <div id="cooldownHUD">
            <div style="margin: 6px 0;">
                <div style="display:flex; justify-content:space-between; font-size:13px;">
                    <span id="spellHudName" style="color:#ffaa00;">ìŠ¤í </span><span id="spellHudCoolText" style="color:#ffaa00">ì¤€ë¹„</span>
                </div>
                <div style="background:#0f3460; border-radius:4px; height:8px; margin-top:3px;">
                    <div id="spellHudCoolBar" style="height:8px; border-radius:4px; background:#ffaa00; width:100%;"></div>
                </div>
            </div>
            <div style="margin: 6px 0;">
                <div style="display:flex; justify-content:space-between; font-size:13px;">
                    <span id="skillNameLabel">ìŠ¤í‚¬</span><span id="skillCoolText" style="color:#ff4444">ì¤€ë¹„</span>
                </div>
                <div style="background:#0f3460; border-radius:4px; height:8px; margin-top:3px;">
                    <div id="skillCoolBar" style="height:8px; border-radius:4px; background:#ff4444; width:100%;"></div>
                </div>
            </div>
        </div>
        <p id="spectateHint" style="display:none; color:#aaa; font-size:12px; margin-top:8px;">í´ë¦­ìœ¼ë¡œ ê´€ì „ ì „í™˜</p>
        <hr style="border-color: #444; margin: 10px 0;">
        <button id="exitToLobbyBtn" style="display:block; width:100%; margin:0; padding:8px; background:#c0392b; color:#fff; border:none; border-radius:6px; font-size:13px; font-weight:bold; cursor:pointer; box-sizing:border-box;">ë‚˜ê°€ê¸° (ëŒ€ê¸°ì‹¤)</button>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

    <script>
        // ========== Firebase ì„¤ì • ==========
        const firebaseConfig = {
            apiKey: "AIzaSyBl2xG5QDEISFwOi-sNqn5eW70BpNuRZdU",
            authDomain: "llnngg.firebaseapp.com",
            databaseURL: "https://llnngg-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "llnngg",
            storageBucket: "llnngg.firebasestorage.app",
            messagingSenderId: "849568964604",
            appId: "1:849568964604:web:d727d027262539887c9c79"
        };

        // Firebase ì´ˆê¸°í™”
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        const roomsRef = database.ref('rooms');

        // í˜„ì¬ ë°© ID (ë°© ì„ íƒ/ìƒì„± í›„ ì„¤ì •ë¨)
        let currentRoomId = null;

        // ë°© ê¸°ë°˜ ë™ì  refs (joinRoom í›„ ì´ˆê¸°í™”)
        let playersRef, gameStateRef, bulletsRef, particlesRef, swingsRef, stabsRef, smokesRef, hitEffectsRef, smithHammersRef, samuraiSlashesRef, parryHitsRef, jumongArrowsRef, muhuiZonesRef, spellEffectsRef;

        function initRoomRefs(roomId) {
            const base = database.ref('rooms/' + roomId);
            playersRef    = base.child('players');
            gameStateRef  = base.child('gameState');
            bulletsRef    = base.child('bullets');
            particlesRef  = base.child('particles');
            swingsRef     = base.child('swings');
            stabsRef      = base.child('stabs');
            smokesRef     = base.child('smokes');
            hitEffectsRef = base.child('hitEffects');
            smithHammersRef = base.child('smithHammers');
            samuraiSlashesRef = base.child('samuraiSlashes');
            parryHitsRef = base.child('parryHits');
            jumongArrowsRef = base.child('jumongArrows');
            muhuiZonesRef   = base.child('muhuiZones');
            spellEffectsRef = base.child('spellEffects');
        }

        // ========== ìŠ¤í  ë°ì´í„° ==========
        const SPELLS = {
            dash: {
                id: 'dash',
                name: 'ëŒ€ì‰¬',
                icon: 'ğŸ’¨',
                description: 'ë§ˆìš°ìŠ¤ ë°©í–¥ìœ¼ë¡œ ë¹ ë¥´ê²Œ ëŒì§„. <span class="tt-buff">â–² ìˆœê°„ ì´ë™</span>',
                cooldown: 3,
                color: '#00fff5'
            },
            heal: {
                id: 'heal',
                name: 'ì¬ìƒ',
                icon: 'ğŸ’š',
                description: '3ì´ˆê°„ ë§¤ì´ˆ ì²´ë ¥ íšŒë³µ. <span class="tt-buff">â™¥ ì´ˆë‹¹ +5 HP Ã— 3</span>',
                cooldown: 15,
                color: '#00ff88'
            },
            rage: {
                id: 'rage',
                name: 'ë¶„ë…¸',
                icon: 'ğŸ”¥',
                description: '4ì´ˆê°„ ì „íˆ¬ë ¥ ê°•í™”. <span class="tt-buff">â–² ê³µê²©ì†ë„ +1</span> <span class="tt-buff">â–² ê³µê²©ë ¥ +10</span>',
                cooldown: 10,
                color: '#ff4400'
            },
            fluid: {
                id: 'fluid',
                name: 'ìœ ì²´í™”',
                icon: 'ğŸŒŠ',
                description: 'ì´ë™ì†ë„ ê¸‰ì¦ í›„ ê°ì†. <span class="tt-buff">â–² ì´ë™ì†ë„ ìµœëŒ€ +1.5</span> â†’ 2ì´ˆ ìœ ì§€ â†’ ê°ì†Œ',
                cooldown: 8,
                color: '#44aaff'
            },
            hourglass: {
                id: 'hourglass',
                name: 'ëª¨ë˜ì‹œê³„',
                icon: 'âŒ›',
                description: '3ì´ˆê°„ ì™„ì „ ë¬´ì . <span class="tt-buff">ğŸ›¡ ë¬´ì </span> <span class="tt-debuff">âœ– í–‰ë™ ë¶ˆê°€</span>',
                cooldown: 20,
                color: '#ffd700'
            }
        };

        // ========== ì§ì—… ë°ì´í„° ==========
        const CLASSES = {
            infantry: {
                id: 'infantry',
                name: 'ë³´ë³‘',
                icon: 'ğŸ”«',
                description: 'ì´ìœ¼ë¡œ ì ì„ ì œì••í•˜ëŠ” ì›ê±°ë¦¬ ì‚¬ê²©ìˆ˜',
                stats: { moveSpeed: 5, attack: 20, attackSpeed: 1.125, health: 100 },
                color: '#4ECDC4',
                bulletSpeed: 22.5,
                skill: { name: 'ì—°ì‚¬', cooldown: 10, bullets: 15, bulletSpeed: 22.5, bulletInterval: 100 },
                // ë°ë¯¸ì§€ ê³„ìˆ˜ (ê³µê²©ë ¥ ê¸°ì¤€ %)
                dmgCoeff: {
                    basic:    { pct: 100, label: 'ê¸°ë³¸ ê³µê²© (2ë°œ)',  section: 'basic' },
                    skill:    { pct:  75, label: 'ì—°ì‚¬ (íƒ„ë‹¹)',      section: 'skill' }
                },
                tooltip: {
                    basic:  'ë§ˆìš°ìŠ¤ ë°©í–¥ìœ¼ë¡œ ì´ì•Œ 2ë°œì„ ë¹ ë¥´ê²Œ ì—°ì† ë°œì‚¬. <span class="tt-dmg">âš” ê³µê²©ë ¥ 100%</span> (íƒ„ë‹¹)',
                    skill:  'ê³ ì •ëœ ë°©í–¥ìœ¼ë¡œ ì´ì•Œ 15ë°œ ì—°ì† ë°œì‚¬. <span class="tt-dmg">âš” ê³µê²©ë ¥ 75%</span> (íƒ„ë‹¹)',
                    skillName: 'ì—°ì‚¬', skillCd: 10
                }
            },
            warrior: {
                id: 'warrior',
                name: 'ì›Œë¦¬ì–´',
                icon: 'âš”ï¸',
                description: 'ê°•ì¸í•œ ê·¼ì ‘ ì „ì‚¬',
                stats: { moveSpeed: 4.5, attack: 20, attackSpeed: 1.5, health: 130 },
                color: '#e74c3c',
                skill: { name: 'ì „íˆ¬ íƒœì„¸', cooldown: 15 },
                dmgCoeff: {
                    basic:    { pct: 100, label: 'ê²€ íœ˜ë‘ë¥´ê¸°', section: 'basic' },
                    spin:     { pct: 100, label: 'íšŒì „ ë² ê¸°',   section: 'skill' }
                },
                tooltip: {
                    basic:  'ì• <span class="tt-neut">â†” 180Â°</span> ë²”ìœ„ë¥¼ ê²€ìœ¼ë¡œ íœ˜ë‘ë¦„. <span class="tt-dmg">âš” ê³µê²©ë ¥ 100%</span>',
                    skill:  '<span class="tt-buff">â–² ì´ë™ì†ë„ +1.5</span> <span class="tt-buff">ğŸ›¡ í”¼í•´ ê°ì†Œ 50%</span> 3ì´ˆ ì§€ì†. ë‹¤ìŒ ê³µê²©ì´ <span class="tt-neut">â†º 360Â° íšŒì „ ë² ê¸°</span>ë¡œ ë³€í™˜.<br>íšŒì „ ë² ê¸°ë¡œ ì ì„ ë§ì¶”ë©´ <span class="tt-buff">ë²„í”„ 3ì´ˆ ë¦¬ì…‹ + íšŒì „ë² ê¸° ìœ ì§€</span>. (ì ì„ ëª» ë§ì¶”ë©´ ë²„í”„ ì†Œë©¸)',
                    skillName: 'ì „íˆ¬ íƒœì„¸', skillCd: 15
                }
            },
            assassin: {
                id: 'assassin',
                name: 'ì–´ìŒ”ì‹ ',
                icon: 'ğŸ—¡ï¸',
                description: 'ì€ì‹ ìœ¼ë¡œ ì ì„ ê¸°ìŠµí•˜ëŠ” ì•”ì‚´ì',
                stats: { moveSpeed: 5.5, attack: 30, attackSpeed: 2.5, health: 80 },
                color: '#9b59b6',
                skill: { name: 'ì€ì‹ ', cooldown: 8 },
                dmgCoeff: {
                    basic: { pct: 100, label: 'ë‹¨ê²€ ì°Œë¥´ê¸°' }
                },
                tooltip: {
                    basic:  'ë§ˆìš°ìŠ¤ ë°©í–¥ìœ¼ë¡œ ë‹¨ê²€ì„ ì°Œë¦„. <span class="tt-dmg">âš” ê³µê²©ë ¥ 100%</span>',
                    skill:  '3ì´ˆê°„ ì€ì‹  ì§„ì…. <span class="tt-buff">â–² ì´ë™ì†ë„ +100%</span> <span class="tt-buff">ğŸ‘ ì ì—ê²Œ ë¹„ê°€ì‹œ</span>. ê³µê²© ë˜ëŠ” ëŒ€ì‰¬ ì‹œ ìë™ í•´ì œ. ì€ì‹  ì¤‘ ê³µê²©ì€ ì¦‰ì‹œ í•´ì œ.',
                    skillName: 'ì€ì‹ ', skillCd: 8
                }
            },
            blacksmith: {
                id: 'blacksmith',
                name: 'ëŒ€ì¥ì¥ì´',
                icon: 'ğŸ”¨',
                description: 'ê°•í™”ë¥¼ ê±°ë“­í• ìˆ˜ë¡ ë”ìš± ê°•í•´ì§€ëŠ” ì „ì¥ì˜ ëŒ€ì¥ì¥ì´',
                stats: { moveSpeed: 4, attack: 10, attackSpeed: 0.5, health: 80 },
                color: '#e67e22',
                skill: { name: 'ê°•í™”', cooldown: 4 },
                dmgCoeff: {
                    basic: { pct: 100, label: 'ë§ì¹˜ ê³µê²©' }
                },
                tooltip: {
                    basic:  'ë§ì¹˜ë¡œ ì•ì„ ê°€ê²©. <span class="tt-dmg">âš” ê³µê²©ë ¥ 100%</span>. ê°•í™” íšŸìˆ˜ì— ë”°ë¼ ê³µê²©ë ¥ ì ì  ì¦ê°€.',
                    skill:  '2ì´ˆ ê²½ì§ í›„ ëŠ¥ë ¥ì¹˜ ì˜êµ¬ ê°•í™”.<br><span class="tt-buff">â–² ì´ë™ì†ë„ +0.25</span> <span class="tt-buff">â–² ê³µê²©ë ¥ +5</span> <span class="tt-buff">â–² ê³µê²©ì†ë„ +0.25</span> <span class="tt-buff">â–² ì²´ë ¥ +10</span>. ë¬´í•œ ì¤‘ì²©.',
                    skillName: 'ê°•í™”', skillCd: 4
                }
            },
            samurai: {
                id: 'samurai',
                name: 'ì‚¬ë¬´ë¼ì´',
                icon: 'â›©ï¸',
                description: 'ë‚ ì¹´ë¡œìš´ ë² ê¸°ì™€ íŒ¨ë§ìœ¼ë¡œ ì ì„ ì œì••í•˜ëŠ” ê²€ê°',
                stats: { moveSpeed: 4.5, attack: 20, attackSpeed: 1, health: 100 },
                color: '#c0392b',
                skill: { name: 'íŒ¨ë§', cooldown: 8 },
                dmgCoeff: {
                    thrust_min: { pct:  25, label: 'ì°¨ì§• ë² ê¸° (ìµœì†Œ)', section: 'basic' },
                    thrust_max: { pct: 175, label: 'ì°¨ì§• ë² ê¸° (ìµœëŒ€)', section: 'basic' },
                    counter:    { pct: 250, label: 'íŒ¨ë§ ë°˜ê²©',        section: 'skill' }
                },
                tooltip: {
                    basic:  'ë§ˆìš°ìŠ¤ ëˆ„ë¥´ëŠ” ì‹œê°„ìœ¼ë¡œ ì°¨ì§•. <span class="tt-dmg">âš” ê³µê²©ë ¥ 25%~175%</span>. ì°¨ì§•ì´ ê¸¸ìˆ˜ë¡ <span class="tt-buff">â–² ëŒì§„ ê±°ë¦¬Â·ë²”ìœ„ ì¦ê°€</span>.',
                    skill:  '1ì´ˆê°„ íŒ¨ë§ ìì„¸. í”¼ê²© ì‹œ <span class="tt-buff">ğŸ›¡ í”¼í•´ ë¬´íš¨í™”</span> í›„ <span class="tt-dmg">âš” ê³µê²©ë ¥ 250% ë°˜ê²© ëŒì§„</span> ë°œë™. ëŒì§„ ì¢…ë£Œ ì‹œ <span class="tt-neut">â†” ì£¼ë³€ ë²”ìœ„ ì¶”ê°€ íƒ€ê²©</span>.',
                    skillName: 'íŒ¨ë§', skillCd: 8
                }
            },
            jumong: {
                id: 'jumong',
                name: 'ì£¼ëª½',
                icon: 'ğŸ¹',
                description: 'ë§µ ëê¹Œì§€ ê¿°ëš«ëŠ” ê°•ë ¥í•œ í™”ì‚´ë¡œ ì›ê±°ë¦¬ ì ì„ ì œì••í•˜ëŠ” ì €ê²© ê¶ìˆ˜',
                stats: { moveSpeed: 3.5, attack: 50, attackSpeed: 0.5, health: 80 },
                color: '#27ae60',
                bulletSpeed: 40,
                skill: { name: 'í˜¸í¬ì•„ì´', cooldown: 8 },
                dmgCoeff: {
                    basic: { pct: 100, label: 'í™”ì‚´' }
                },
                tooltip: {
                    basic:  'ë§µ ëê¹Œì§€ ë‚ ì•„ê°€ëŠ” í™”ì‚´ 1ë°œ. <span class="tt-dmg">âš” ê³µê²©ë ¥ 100%</span>. <span class="tt-neut">ì‚¬ê±°ë¦¬ ë¬´ì œí•œ</span>',
                    skill:  '4ì´ˆê°„ <span class="tt-buff">â–² ì‹œì•¼ ë²”ìœ„ +87.5%</span>. í”¼í•´ ë³€í™” ì—†ìŒ.',
                    skillName: 'í˜¸í¬ì•„ì´', skillCd: 8
                }
            },
            muhui: {
                id: 'muhui',
                name: 'ë¬´í¬',
                icon: 'ğŸŒ¸',
                description: 'í™”ë ¤í•œ ëª¸ì§“ìœ¼ë¡œ ë²šê½ƒ ë¹„ìˆ˜ë¥¼ í¼ë¶“ê³  ì¶¤ì‚¬ìœ„ë¡œ ì ì˜ ë°œëª©ì„ ì¡ëŠ” ì†ì‚¬ ì¹´ì´í„°',
                stats: { moveSpeed: 5.5, attack: 5, attackSpeed: 2.5, health: 60 },
                color: '#e91e8c',
                skill: { name: 'ê½ƒë³´ë¼ ì¶¤', cooldown: 15 },
                dmgCoeff: {
                    basic:    { pct: 100, label: 'ë²šê½ƒ ë¹„ìˆ˜ (íƒ„ë‹¹)', section: 'basic' },
                    zone_dps: { pct:   0, label: 'ì¥íŒ (ì´ˆë‹¹ ê³ ì •)', section: 'skill' }   // ê³ ì • 10
                },
                tooltip: {
                    basic:  'ë¶€ì±„ê¼´ <span class="tt-neut">60Â°</span> ë°©í–¥ìœ¼ë¡œ ë¹„ìˆ˜ 7ë°œ ë™ì‹œ ë°œì‚¬. <span class="tt-dmg">âš” ê³µê²©ë ¥ 100%</span> (íƒ„ë‹¹)',
                    skill:  'ë¬´í¬ë¥¼ ì¤‘ì‹¬ìœ¼ë¡œ ì£¼ë³€ ì˜ì—­ì´ <span class="tt-neut">5ì´ˆê°„ ì¥íŒ êµ¬ì—­</span>ìœ¼ë¡œ ë³€í™˜. êµ¬ì—­ ì•ˆ ì ì—ê²Œ <span class="tt-dmg">âš” ì´ˆë‹¹ 10 ê³ ì • í”¼í•´</span>. ë¬´í¬ê°€ ì´ë™í•˜ë©´ êµ¬ì—­ë„ í•¨ê»˜ ì´ë™.',
                    skillName: 'ê½ƒë³´ë¼ ì¶¤', skillCd: 15
                }
            }
        };

        // ì›Œë¦¬ì–´ ì „ìš© ìƒíƒœ
        let warriorSkillActive = false;       // ìŠ¤í‚¬ í™œì„±í™” ì—¬ë¶€
        let warriorSkillEnd = 0;              // ìŠ¤í‚¬ ì¢…ë£Œ ì‹œê°„
        let warriorSpinReady = false;         // íšŒì „ ê³µê²© ì¤€ë¹„ ì—¬ë¶€
        let warriorSwingActive = false;       // ê²€ íœ˜ë‘ë¥´ê¸° ì• ë‹ˆë©”ì´ì…˜ ì¤‘
        let warriorSwingAngle = 0;            // í˜„ì¬ íœ˜ë‘ë¥´ê¸° ê°ë„
        let warriorSwingDir = 0;              // íœ˜ë‘ë¥´ê¸° ê¸°ì¤€ ê°ë„
        let warriorSwingFrames = 0;           // ë‚¨ì€ ì• ë‹ˆë©”ì´ì…˜ í”„ë ˆì„
        const WARRIOR_SWING_TOTAL = 10;       // íœ˜ë‘ë¥´ê¸° ì´ í”„ë ˆì„
        const WARRIOR_SWING_RANGE = 102;      // ê²€ ë„ë‹¬ ë²”ìœ„ (px) â€” ê¸°ì¡´ 85ì˜ 120%
        const WARRIOR_SPIN_RANGE = 170;       // íšŒì „ ê³µê²© ë²”ìœ„ (px) â€” ê¸°ì¡´ 85ì˜ 200%
        const WARRIOR_SWING_ARC = Math.PI * 1.0; // 180ë„ í˜¸
        const WARRIOR_SPIN_ARC = Math.PI * 2;    // 360ë„ í˜¸
        const swingHitIds = new Set();        // ì´ë²ˆ íœ˜ë‘ë¥´ê¸°ì—ì„œ ì´ë¯¸ ë§ì€ ëŒ€ìƒ
        let _currentSwingArc = Math.PI * 1.0; // í˜„ì¬ íœ˜ë‘ë¥´ê¸° ê°ë„ ë²”ìœ„
        let _currentSwingRange = WARRIOR_SWING_RANGE; // í˜„ì¬ íœ˜ë‘ë¥´ê¸° ë²”ìœ„

        // ì–´ìŒ”ì‹  ì „ìš© ìƒíƒœ
        let assassinStealthActive = false;    // ì€ì‹  ì—¬ë¶€
        let assassinStealthEnd = 0;           // ì€ì‹  ì¢…ë£Œ ì‹œê°„
        const ASSASSIN_STAB_RANGE = 65;       // ì°Œë¥´ê¸° ì‚¬ê±°ë¦¬
        const ASSASSIN_STAB_TOTAL = 8;        // ì°Œë¥´ê¸° ì• ë‹ˆë©”ì´ì…˜ í”„ë ˆì„
        let assassinStabActive = false;       // ì°Œë¥´ê¸° ì• ë‹ˆë©”ì´ì…˜ ì¤‘
        let assassinStabFrames = 0;           // ë‚¨ì€ í”„ë ˆì„
        let assassinStabDir = 0;              // ì°Œë¥´ê¸° ë°©í–¥
        let assassinStabHit = false;          // ì´ë²ˆ ì°Œë¥´ê¸°ì—ì„œ ì´ë¯¸ íˆíŠ¸
        const assassinSmokeParticles = [];    // ì—°ê¸° íŒŒí‹°í´ (ë¡œì»¬)

        // ëŒ€ì¥ì¥ì´ ì „ìš© ìƒíƒœ
        let smithForging = false;             // ê°•í™” ê²½ì§ ì¤‘ ì—¬ë¶€
        let smithForgeEnd = 0;                // ê²½ì§ ì¢…ë£Œ ì‹œê°„
        let smithEnhanceLevel = 0;            // ê°•í™” íšŸìˆ˜ (ê²Œì„ ë‚´ ë¦¬ì…‹)
        let smithHammerActive = false;        // ë§ì¹˜ ê³µê²© ì• ë‹ˆë©”ì´ì…˜ ì¤‘
        let smithHammerFrames = 0;            // ë§ì¹˜ ê³µê²© ë‚¨ì€ í”„ë ˆì„
        let smithHammerDir = 0;              // ë§ì¹˜ ë°©í–¥
        let smithHammerHit = false;           // ì´ë²ˆ ê³µê²©ì—ì„œ íˆíŠ¸
        const SMITH_HAMMER_TOTAL = 12;        // ë§ì¹˜ ê³µê²© ì´ í”„ë ˆì„
        const SMITH_HAMMER_HIT_FRAME = 4;     // ì´ í”„ë ˆì„ ì´í›„ë¶€í„° íˆíŠ¸ íŒì •
        const SMITH_HAMMER_RANGE = 55;        // ë§ì¹˜ ë„ë‹¬ ë²”ìœ„ (ì‚¬ê°í˜• í­ ì ˆë°˜)
        const SMITH_HAMMER_HEIGHT = 60;       // ì‚¬ê°í˜• ë†’ì´
        const smithHammerHitIds = new Set();  // ì´ë²ˆ ê³µê²©ì—ì„œ ë§ì€ ëŒ€ìƒ
        const playerHammers = {};             // ë‹¤ë¥¸ í”Œë ˆì´ì–´ ë§ì¹˜ ê³µê²© ìƒíƒœ

        // ì£¼ëª½ ì „ìš© ìƒíƒœ
        let jumongHawkeyeActive = false;
        let jumongHawkeyeEnd = 0;
        let jumongCurrentZoom = 1.0;       // í˜„ì¬ ì‹¤ì œ ì ìš© ì¤Œ (ë³´ê°„ìš©)
        let jumongTargetZoom  = 1.0;       // ëª©í‘œ ì¤Œ
        const JUMONG_HAWKEYE_DURATION = 4000;   // í˜¸í¬ì•„ì´ ì§€ì† (ms)
        const JUMONG_HAWKEYE_ZOOM = 1.875;      // ì‹œì•¼ ë°°ìœ¨ (2.5ì—ì„œ 25% ê°ì†Œ)
        const JUMONG_ARROW_SPEED = 40;          // í™”ì‚´ ì†ë„ (ë¹ ë¦„)
        const JUMONG_ARROW_RANGE = 4000;        // ìµœëŒ€ ì‚¬ê±°ë¦¬ (ë§µ ëŒ€ê°ì„  ì´ìƒ)
        const playerJumongArrows = {};          // ë‹¤ë¥¸ í”Œë ˆì´ì–´ í™”ì‚´ ì‹œê° íš¨ê³¼

        // ë¬´í¬ ì „ìš© ìƒíƒœ
        let muhuiZoneActive = false;
        let muhuiZoneEnd = 0;
        const MUHUI_ZONE_DURATION = 5000;       // ì¥íŒ ì§€ì† (ms)
        const MUHUI_ZONE_RADIUS = 280;          // ì¥íŒ ë°˜ê²½ (í™•ì¥)
        const MUHUI_ZONE_DPS = 10;              // ì´ˆë‹¹ í”¼í•´
        const MUHUI_PETAL_RANGE = 440;          // ë²šê½ƒë¹„ìˆ˜ ìµœëŒ€ ì‚¬ê±°ë¦¬ (2ë°°)
        const MUHUI_PETAL_COUNT = 7;            // ë°œì‚¬ ìˆ˜
        const MUHUI_PETAL_SPREAD = Math.PI / 4.5; // ë¶€ì±„ê¼´ ê°ë„ (40ë„)
        const MUHUI_PETAL_SPEED = 14;
        let muhuiZoneDmgTimer = 0;              // ì¥íŒ í‹± ì¹´ìš´í„°
        const playerMuhuiZones = {};            // ë‹¤ë¥¸ í”Œë ˆì´ì–´ ì¥íŒ ìƒíƒœ


        // ì‚¬ë¬´ë¼ì´ ì „ìš© ìƒíƒœ
        const SAMURAI_SLASH_TOTAL = 10;       // ì°Œë¥´ê¸° ì• ë‹ˆë©”ì´ì…˜ ì´ í”„ë ˆì„
        const SAMURAI_MAX_CHARGE = 2000;      // ìµœëŒ€ ì°¨ì§• ì‹œê°„ (ms) â€” í’€ì°¨ì§• 2ì´ˆ
        // ì°¨ì§• ë‹¨ê³„ë³„ ìŠ¤íƒ¯ (0~6ë‹¨ê³„, 2000ms ê¸°ì¤€ ê· ë“± ë¶„ë°°)
        const SAMURAI_CHARGE_LEVELS = [
            { minTime: 0,    maxTime: 334,  dmg: 5,  length: 80,  width: 30, dashFrames: 5,  dashSpeed: 10 },
            { minTime: 334,  maxTime: 667,  dmg: 10, length: 105, width: 36, dashFrames: 6,  dashSpeed: 11 },
            { minTime: 667,  maxTime: 1000, dmg: 15, length: 130, width: 40, dashFrames: 7,  dashSpeed: 12 },
            { minTime: 1000, maxTime: 1334, dmg: 20, length: 155, width: 44, dashFrames: 8,  dashSpeed: 13 },
            { minTime: 1334, maxTime: 1667, dmg: 25, length: 175, width: 48, dashFrames: 9,  dashSpeed: 14 },
            { minTime: 1667, maxTime: 2000, dmg: 30, length: 195, width: 52, dashFrames: 10, dashSpeed: 15 },
            { minTime: 2000, maxTime: 9999, dmg: 35, length: 220, width: 58, dashFrames: 12, dashSpeed: 17 },
        ];
        // ì°¨ì§• ìƒíƒœ
        let samuraiCharging = false;          // ë§ˆìš°ìŠ¤ ëˆ„ë¥´ê³  ìˆìŒ
        let samuraiChargeStart = 0;           // ì°¨ì§• ì‹œì‘ ì‹œê°
        let samuraiChargeDir = 0;             // ì°¨ì§• ë°©í–¥ (ëˆ„ë¥¼ ë•Œ ë§ˆìš°ìŠ¤ ë°©í–¥)
        let samuraiChargeTimerId = null;      // ìë™ë°œì‚¬ setTimeout ID (ì¤‘ë³µ ë°©ì§€)
        let samuraiCurrentLevel = null;       // ë°œì‚¬ ì‹œ í™•ì •ëœ ë ˆë²¨ ê°ì²´
        let samuraiSlashActive = false;       // ì°Œë¥´ê¸° ì¤‘
        let samuraiSlashFrames = 0;           // ë‚¨ì€ í”„ë ˆì„
        let samuraiSlashDir = 0;              // ì°Œë¥´ê¸° ë°©í–¥
        let samuraiSlashProgress = 0;         // ì°Œë¥´ê¸° ì§„í–‰ë„ (0~1)
        let samuraiSlashDashFrames = 0;       // ëŒì§„ ë‚¨ì€ í”„ë ˆì„
        let samuraiSlashDashVx = 0;
        let samuraiSlashDashVy = 0;
        const samuraiSlashHitIds = new Set(); // ì´ë²ˆ ì°Œë¥´ê¸°ì— ë§ì€ ëŒ€ìƒ

        let samuraiParryActive = false;       // íŒ¨ë§ ê²½ì§ ì¤‘
        let samuraiParryEnd = 0;              // íŒ¨ë§ ì¢…ë£Œ ì‹œê°„
        let samuraiParryHit = false;          // íŒ¨ë§ ì¤‘ ê³µê²© ë°›ì•˜ëŠ”ì§€
        let samuraiParryDir = 0;              // íŒ¨ë§ ì‹œ ë°”ë¼ë³´ë˜ ë°©í–¥ (ë°˜ê²© ëŒì§„ìš©)
        let samuraiCounterActive = false;     // ë°˜ê²© ëŒì§„ ì¤‘
        let samuraiCounterFrames = 0;         // ë°˜ê²© ëŒì§„ ë‚¨ì€ í”„ë ˆì„
        let samuraiCounterVx = 0;
        let samuraiCounterVy = 0;
        const SAMURAI_COUNTER_FRAMES = 14;    // ë°˜ê²© ëŒì§„ ì§€ì† í”„ë ˆì„
        const SAMURAI_COUNTER_SPEED = 20;     // ë°˜ê²© ëŒì§„ ì†ë„
        const SAMURAI_COUNTER_DMG_PCT = 2.5;  // ë°˜ê²© í”¼í•´ = ê³µê²©ë ¥ Ã— 250%
        const samuraiCounterHitIds = new Set();

        const playerSamuraiSlashes = {};      // ë‹¤ë¥¸ í”Œë ˆì´ì–´ ë² ê¸° ìƒíƒœ
        const playerParries = {};             // ë‹¤ë¥¸ í”Œë ˆì´ì–´ íŒ¨ë§ ìƒíƒœ

        // ========== ê²Œì„ ìƒíƒœ ==========
        const GAME_STATUS = {
            LOBBY: 'LOBBY',
            PLAYING: 'PLAYING'
        };

        const GAME_MODE = {
            NORMAL: 'NORMAL',      // ì¼ë°˜ ëª¨ë“œ (2ì¸ ì´ìƒ, ìµœí›„ 1ì¸ ìŠ¹ë¦¬)
            PRACTICE: 'PRACTICE'   // ì—°ìŠµ ëª¨ë“œ (1ì¸ ê°€ëŠ¥, í—ˆìˆ˜ì•„ë¹„, ì¦‰ì‹œ ë¶€í™œ)
        };

        let myPlayerId = null;
        let myNickname = null;
        let myClass = null;
        let isHost = false;
        let isReady = false;
        let gameStatus = GAME_STATUS.LOBBY;
        let gameMode = GAME_MODE.NORMAL;  // í˜„ì¬ ê²Œì„ ëª¨ë“œ

        const players = {};
        const playerRenderPos = {}; // ë‹¤ë¥¸ í”Œë ˆì´ì–´ ë³´ê°„ ë Œë”ë§ ìœ„ì¹˜
        const keys = {};
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const PLAYER_SIZE = 30;

        // í—ˆìˆ˜ì•„ë¹„ (ì—°ìŠµ ëª¨ë“œ ì „ìš©)
        const DUMMY_ID = 'training_dummy';
        function createDummyData() {
            return {
                id: DUMMY_ID,
                nickname: 'í›ˆë ¨ìš© í—ˆìˆ˜ì•„ë¹„',
                x: 750 - PLAYER_SIZE / 2,
                y: 750 - PLAYER_SIZE / 2,
                health: 999999,
                maxHealth: 999999,
                color: '#888888',
                isSpectator: false,
                isDummy: true
            };
        }

        // â”€â”€ í—ˆìˆ˜ì•„ë¹„ DPS/ë°ë¯¸ì§€ ì¸¡ì • â”€â”€
        let dummyDmgTotal = 0;        // ëˆ„ì  í”¼í•´ëŸ‰
        let dummyDmgWindow = [];      // ìµœê·¼ 1ì´ˆ í”¼í•´ ê¸°ë¡ [{time, dmg}]
        let dummyDps = 0;             // í˜„ì¬ DPS
        let dummyLastHit = 0;         // ë§ˆì§€ë§‰ í”¼í•´ëŸ‰
        let dummyFloatingNums = [];   // í”Œë¡œíŒ… ë°ë¯¸ì§€ ìˆ«ì
        // â”€â”€ í—ˆìˆ˜ì•„ë¹„ ì´ì•Œ ë°œì‚¬ (ì—°ìŠµ ëª¨ë“œ) â”€â”€
        let dummyShootTimer = 0;
        const DUMMY_SHOOT_INTERVAL = 90; // í”„ë ˆì„(60fps ê¸°ì¤€ 1.5ì´ˆ)
        const DUMMY_BULLET_SPEED = 5;    // ëŠë¦° ì´ì•Œ
        const DUMMY_BULLET_DMG = 20;     // ë³´ë³‘ ë°ë¯¸ì§€ì™€ ë™ì¼

        // ì¹´ë©”ë¼ ì˜¤í”„ì…‹
        let cameraX = 0;
        let cameraY = 0;

        // ê´€ì „ ì‹œìŠ¤í…œ
        let isSpectating = false;
        let spectateTargetId = null;
        let isAlive = true;

        // Rí‚¤ ê°•ì œ ì¢…ë£Œ ì‹œìŠ¤í…œ
        let rKeyPressStart = 0;
        let rKeyHolding = false;
        let forceStopProgress = 0; // 0~100%

        // ì „íˆ¬ ì‹œìŠ¤í…œ
        const bullets = []; // ëª¨ë“  ì´ì•Œ
        let lastAttackTime = 0;
        let skillCooldownEnd = 0;
        let isUsingSkill = false;
        let skillBulletCount = 0;
        let skillDirection = { x: 0, y: 0 };
        let lastSkillBullet = 0;

        // ëŒ€ì‰¬ ì‹œìŠ¤í…œ (ëŒì§„ ë©”ì»¤ë‹ˆì¦˜)
        let dashCooldownEnd = 0;
        const DASH_COOLDOWN = 3;
        let isDashing = false;
        let dashVx = 0;
        let dashVy = 0;
        let dashRemainFrames = 0;
        const DASH_TOTAL_FRAMES = 12;   // ëŒì§„ ì§€ì† í”„ë ˆì„
        // DASH_SPEEDëŠ” ì´ë™ì†ë„ ë¹„ë¡€ë¡œ performDashì—ì„œ ê³„ì‚° (ê¸°ì¤€: moveSpeed 5 â†’ speed 28)

        // ========== ìŠ¤í  ì‹œìŠ¤í…œ ==========
        let mySpell = 'dash';           // ì„ íƒí•œ ìŠ¤í  ID
        let spellCooldownEnd = 0;       // ìŠ¤í  ì¿¨íƒ€ì„ ì¢…ë£Œ ì‹œê°

        // ì¬ìƒ ìƒíƒœ
        let healActive = false;
        let healTicks = 0;
        let healTimer = 0;

        // ë¶„ë…¸ ìƒíƒœ
        let rageActive = false;
        let rageEnd = 0;

        // ìœ ì²´í™” ìƒíƒœ
        let fluidActive = false;
        let fluidEnd = 0;
        let fluidPhase = 'ramp';  // 'ramp'|'hold'|'decay'
        let fluidBonus = 0;       // í˜„ì¬ ì†ë„ ë³´ë„ˆìŠ¤ (0~1.5)

        // ëª¨ë˜ì‹œê³„ ìƒíƒœ
        let hourglassActive = false;
        let hourglassEnd = 0;

        // ë‹¤ë¥¸ í”Œë ˆì´ì–´ ìŠ¤í  ì´í™íŠ¸ ìƒíƒœ
        const playerSpellEffects = {}; // playerId â†’ {spell, startedAt, data}

        // íŒŒí‹°í´ (ëŒ€ì‰¬ ë¨¼ì§€/ì”ìƒ)
        const particles = [];
        const particleIds = new Set(); // ì¤‘ë³µ ìˆ˜ì‹  ë°©ì§€ìš©

        // íˆíŠ¸ ì´í™íŠ¸
        const hitEffects = [];

        // ì´ì•Œ ID ì¤‘ë³µ ë°©ì§€ìš©
        const bulletIds = new Set();

        // ëª¨ë“  í”Œë ˆì´ì–´ ìŠ¤ìœ™ ìƒíƒœ (playerId â†’ swingState)
        const playerSwings = {};
        // ëª¨ë“  í”Œë ˆì´ì–´ ì°Œë¥´ê¸° ìƒíƒœ (playerId â†’ stabState)
        const playerStabs = {};

        // ë§µ í¬ê¸°
        const MAP_W = 1500;
        const MAP_H = 1500;

        // ë§ˆìš°ìŠ¤ ìœ„ì¹˜
        let mouseX = 0;
        let mouseY = 0;
        let _lastPosWrite = 0; // Firebase ìœ„ì¹˜ ì—…ë°ì´íŠ¸ ì“°ë¡œí‹€ìš©
        let _domMyHealth = null; // DOM ìºì‹œ

        // ========== í™”ë©´ ì „í™˜ ==========
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            // gameContainerëŠ” .screen í´ë˜ìŠ¤ê°€ ì•„ë‹ˆë¯€ë¡œ ë³„ë„ ì²˜ë¦¬
            const gameContainer = document.getElementById('gameContainer');
            if (screenId === 'gameContainer') {
                gameContainer.style.display = 'flex';
            } else {
                gameContainer.style.display = 'none';
                document.getElementById(screenId).classList.add('active');
            }
        }

        // ========== ë‹‰ë„¤ì„ ì…ë ¥ ==========
        document.getElementById('nicknameNextBtn').addEventListener('click', () => {
            const nickname = document.getElementById('nicknameInput').value.trim();
            if (!nickname) {
                document.getElementById('nicknameError').textContent = 'ë‹‰ë„¤ì„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”!';
                return;
            }
            myNickname = nickname;
            document.getElementById('myNickname').textContent = myNickname;
            showScreen('roomScreen');
            startRoomListListener();
        });

        document.getElementById('nicknameInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                document.getElementById('nicknameNextBtn').click();
            }
        });

        // ========== ì§ì—… ì„ íƒ ìŠ¬ë¼ì´ë” ==========
        let currentClassIndex = 0;
        let classIds = [];

        function renderClassSelection() {
            const slider = document.getElementById('classSlider');
            const dotsContainer = document.getElementById('swiperDots');
            slider.innerHTML = '';
            dotsContainer.innerHTML = '';
            classIds = Object.keys(CLASSES);

            classIds.forEach((classId, index) => {
                const classData = CLASSES[classId];
                
                // ìŠ¬ë¼ì´ë“œ ìƒì„±
                const slide = document.createElement('div');
                slide.className = 'class-slide';
                slide.innerHTML = `
                    <div class="class-card">
                        <div class="class-icon">${classData.icon}</div>
                        <h3>${classData.name}</h3>
                        <p class="description">${classData.description}</p>
                        <div class="stats">
                            <div>âš¡ ì´ë™ì†ë„: ${classData.stats.moveSpeed}</div>
                            <div>âš”ï¸ ê³µê²©ë ¥: ${classData.id === 'samurai' ? '25%~175% (ì°¨ì§•)' : classData.stats.attack}</div>
                            <div>â±ï¸ ê³µê²©ì†ë„: ${classData.stats.attackSpeed}/ì´ˆ</div>
                            <div>â¤ï¸ ì²´ë ¥: ${classData.stats.health}</div>
                        </div>
                    </div>
                `;
                slider.appendChild(slide);

                // ë„íŠ¸ ìƒì„±
                const dot = document.createElement('div');
                dot.className = 'swiper-dot' + (index === 0 ? ' active' : '');
                dot.addEventListener('click', () => goToSlide(index));
                dotsContainer.appendChild(dot);
            });

            // ì²« ì§ì—… ìë™ ì„ íƒ
            selectClassByIndex(0);

            // ë„¤ë¹„ê²Œì´ì…˜ ì´ë²¤íŠ¸
            document.getElementById('swiperPrev').addEventListener('click', prevSlide);
            document.getElementById('swiperNext').addEventListener('click', nextSlide);

            // í„°ì¹˜ ìŠ¤ì™€ì´í”„ ì§€ì›
            let touchStartX = 0;
            let touchEndX = 0;
            slider.addEventListener('touchstart', e => touchStartX = e.changedTouches[0].screenX);
            slider.addEventListener('touchend', e => {
                touchEndX = e.changedTouches[0].screenX;
                if (touchStartX - touchEndX > 50) nextSlide();
                if (touchEndX - touchStartX > 50) prevSlide();
            });

            // í‚¤ë³´ë“œ í™”ì‚´í‘œ ì§€ì›
            document.addEventListener('keydown', function classKeyHandler(e) {
                if (document.getElementById('classScreen').classList.contains('active')) {
                    if (e.key === 'ArrowLeft') prevSlide();
                    if (e.key === 'ArrowRight') nextSlide();
                }
            });
        }

        function goToSlide(index) {
            currentClassIndex = index;
            const slider = document.getElementById('classSlider');
            slider.style.transform = `translateX(-${index * 100}%)`;
            
            // ë„íŠ¸ ì—…ë°ì´íŠ¸
            document.querySelectorAll('.swiper-dot').forEach((dot, i) => {
                dot.classList.toggle('active', i === index);
            });

            selectClassByIndex(index);
        }

        function prevSlide() {
            goToSlide(currentClassIndex > 0 ? currentClassIndex - 1 : classIds.length - 1);
        }

        function nextSlide() {
            goToSlide(currentClassIndex < classIds.length - 1 ? currentClassIndex + 1 : 0);
        }

        function selectClassByIndex(index) {
            myClass = classIds[index];
            document.getElementById('classSelectBtn').disabled = false;
            renderClassTooltip(myClass);
        }

        // ========== ì§ì—… íˆ´íŒ íŒ¨ë„ ë Œë”ë§ ==========
        function renderClassTooltip(classId) {
            const panel = document.getElementById('classTooltipContent');
            if (!panel) return;
            const cd = CLASSES[classId];
            if (!cd) return;

            const stats = cd.stats;

            // ë°ë¯¸ì§€ ê³„ìˆ˜ ë°°ì§€ HTML ë¹Œë”
            function coeffBadge(coeff) {
                if (!coeff) return '';
                const isFixed = coeff.pct === 0;
                const badge = isFixed
                    ? `<span class="tooltip-coeff-badge fixed">ê³ ì •</span>`
                    : `<span class="tooltip-coeff-badge">${coeff.pct}%</span>`;
                return `<div class="tooltip-coeff-row">${badge}<span class="tooltip-coeff-label">${coeff.label}</span></div>`;
            }

            // section í”Œë˜ê·¸ ê¸°ì¤€ìœ¼ë¡œ ê¸°ë³¸/ìŠ¤í‚¬ ê³„ìˆ˜ ë¶„ë¦¬
            let basicCoeffHTML = '';
            let skillCoeffHTML = '';
            if (cd.dmgCoeff) {
                Object.values(cd.dmgCoeff).forEach(c => {
                    const badge = coeffBadge(c);
                    if (!c.section || c.section === 'basic') basicCoeffHTML += badge;
                    else skillCoeffHTML += badge;
                });
            }

            panel.innerHTML = `
                <div style="display:flex; align-items:center; gap:12px; margin-bottom:14px; border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:14px;">
                    <span style="font-size:44px;">${cd.icon}</span>
                    <div>
                        <div style="font-size:22px; font-weight:bold; color:#00fff5;">${cd.name}</div>
                        <div style="font-size:12px; color:#aaa; margin-top:2px;">${cd.description}</div>
                    </div>
                </div>

                <div class="tooltip-section-title">ğŸ“Š ê¸°ë³¸ ìŠ¤íƒ¯</div>
                <div class="tooltip-stat-grid">
                    <div class="tooltip-stat-item">âš¡ ì´ë™ì†ë„ <span>${stats.moveSpeed}</span></div>
                    <div class="tooltip-stat-item">â¤ï¸ ì²´ë ¥ <span>${stats.health}</span></div>
                    <div class="tooltip-stat-item">âš”ï¸ ê³µê²©ë ¥ <span>${classId === 'samurai' ? '25%~175%' : stats.attack}</span></div>
                    <div class="tooltip-stat-item">â±ï¸ ê³µê²©ì†ë„ <span>${stats.attackSpeed}/ì´ˆ</span></div>
                </div>

                <div class="tooltip-section-title">âš”ï¸ ê¸°ë³¸ ê³µê²©</div>
                <div class="tooltip-ability">
                    <div class="tooltip-skill-header">
                        <span class="tooltip-skill-name">ê¸°ë³¸ ê³µê²©</span>
                        <span class="tooltip-skill-cd" style="color:#00fff5;background:rgba(0,255,245,0.1);border-color:rgba(0,255,245,0.25);">âš¡ ${stats.attackSpeed}/ì´ˆ</span>
                    </div>
                    ${basicCoeffHTML}
                    ${cd.tooltip ? cd.tooltip.basic : ''}
                </div>

                <div class="tooltip-section-title">âœ¨ íŠ¹ìˆ˜ ëŠ¥ë ¥ (ìš°í´ë¦­)</div>
                <div class="tooltip-ability skill-block">
                    <div class="tooltip-skill-header">
                        <span class="tooltip-skill-name">${cd.tooltip && cd.tooltip.skillName ? cd.tooltip.skillName : (cd.skill ? cd.skill.name : '')}</span>
                        <span class="tooltip-skill-cd">â± ì¿¨íƒ€ì„ ${cd.skill ? cd.skill.cooldown : '?'}ì´ˆ</span>
                    </div>
                    ${skillCoeffHTML}
                    ${cd.tooltip ? cd.tooltip.skill : ''}
                </div>
            `;
        }

        // ========== ëŒ€ê¸°ì‹¤ ì§ì—… ì„ íƒ ìŠ¬ë¼ì´ë” ==========
        let lobbyClassIndex = 0;
        let lobbyClassIds = [];

        function renderLobbyClassSelection() {
            const slider = document.getElementById('lobbyClassSlider');
            const dotsContainer = document.getElementById('lobbyClassDots');
            if (!slider || !dotsContainer) return;
            slider.innerHTML = '';
            dotsContainer.innerHTML = '';
            lobbyClassIds = Object.keys(CLASSES);

            lobbyClassIds.forEach((classId, index) => {
                const cd = CLASSES[classId];
                const slide = document.createElement('div');
                slide.className = 'lby-class-slide';
                slide.innerHTML = `
                    <div class="lby-class-card">
                        <div class="lcc-icon">${cd.icon}</div>
                        <div class="lcc-name">${cd.name}</div>
                    </div>`;
                slider.appendChild(slide);

                const dot = document.createElement('div');
                dot.className = 'swiper-dot' + (index === 0 ? ' active' : '');
                dot.addEventListener('click', () => goToLobbySlide(index));
                dotsContainer.appendChild(dot);
            });

            // í„°ì¹˜ ìŠ¤ì™€ì´í”„
            let tsX = 0;
            const sw = document.getElementById('lobbyClassSwiper');
            sw.addEventListener('touchstart', e => { tsX = e.touches[0].clientX; }, {passive:true});
            sw.addEventListener('touchend', e => {
                const dx = e.changedTouches[0].clientX - tsX;
                if (Math.abs(dx) > 40) {
                    if (dx < 0) goToLobbySlide(lobbyClassIndex < lobbyClassIds.length - 1 ? lobbyClassIndex + 1 : 0);
                    else goToLobbySlide(lobbyClassIndex > 0 ? lobbyClassIndex - 1 : lobbyClassIds.length - 1);
                }
            }, {passive:true});

            goToLobbySlide(lobbyClassIndex);
            document.getElementById('lobbySwiperPrev').onclick = () => {
                goToLobbySlide(lobbyClassIndex > 0 ? lobbyClassIndex - 1 : lobbyClassIds.length - 1);
            };
            document.getElementById('lobbySwiperNext').onclick = () => {
                goToLobbySlide(lobbyClassIndex < lobbyClassIds.length - 1 ? lobbyClassIndex + 1 : 0);
            };
        }

        function goToLobbySlide(index) {
            lobbyClassIndex = index;
            const slider = document.getElementById('lobbyClassSlider');
            if (slider) slider.style.transform = `translateX(-${index * 100}%)`;
            document.querySelectorAll('#lobbyClassDots .swiper-dot').forEach((dot, i) => {
                dot.classList.toggle('active', i === index);
            });
            myClass = lobbyClassIds[index];
            renderLobbyClassInfo(myClass);
            if (myPlayerId && playersRef) {
                const cd = CLASSES[myClass];
                playersRef.child(myPlayerId).update({
                    class: myClass, className: cd.name, color: cd.color, stats: cd.stats
                });
            }
            const err = document.getElementById('lobbyClassError');
            if (err) err.textContent = '';
        }

        // ì§ì—… ì •ë³´ â€” ìŠ¬ë¼ì´ë” ì•„ë˜ íŒ¨ë„ì— ë Œë”ë§
        function renderLobbyClassInfo(classId) {
            const panel = document.getElementById('lobbyClassInfo');
            if (!panel) return;
            const cd = CLASSES[classId];
            if (!cd) return;

            function coeffBadge(c) {
                if (!c) return '';
                const b = c.pct === 0
                    ? `<span class="tooltip-coeff-badge fixed">ê³ ì •</span>`
                    : `<span class="tooltip-coeff-badge">${c.pct}%</span>`;
                return `<div class="tooltip-coeff-row">${b}<span class="tooltip-coeff-label">${c.label}</span></div>`;
            }
            let basicCoeffHTML2 = '';
            let skillCoeffHTML2 = '';
            if (cd.dmgCoeff) Object.values(cd.dmgCoeff).forEach(c => {
                const badge = coeffBadge(c);
                if (!c.section || c.section === 'basic') basicCoeffHTML2 += badge;
                else skillCoeffHTML2 += badge;
            });

            panel.innerHTML = `
                <div class="tooltip-stat-grid" style="padding:10px 14px 6px;">
                    <div class="tooltip-stat-item">âš¡ ì´ë™ <span>${cd.stats.moveSpeed}</span></div>
                    <div class="tooltip-stat-item">â¤ï¸ ì²´ë ¥ <span>${cd.stats.health}</span></div>
                    <div class="tooltip-stat-item">âš”ï¸ ê³µê²© <span>${classId==='samurai'?'25%~175%':cd.stats.attack}</span></div>
                    <div class="tooltip-stat-item">â±ï¸ ì†ë„ <span>${cd.stats.attackSpeed}/s</span></div>
                </div>
                <div style="padding:0 14px 12px;">
                    <div class="tooltip-section-title">ê¸°ë³¸ ê³µê²©</div>
                    <div class="tooltip-ability">
                        <div class="tooltip-skill-header">
                            <span class="tooltip-skill-name">ê¸°ë³¸ ê³µê²©</span>
                            <span class="tooltip-skill-cd" style="color:#00fff5;background:rgba(0,255,245,0.1);border-color:rgba(0,255,245,0.25);">âš¡ ${cd.stats.attackSpeed}/ì´ˆ</span>
                        </div>
                        ${basicCoeffHTML2}${cd.tooltip ? cd.tooltip.basic : ''}
                    </div>
                    <div class="tooltip-section-title">ìŠ¤í‚¬ (ìš°í´ë¦­)</div>
                    <div class="tooltip-ability skill-block">
                        <div class="tooltip-skill-header">
                            <span class="tooltip-skill-name">${cd.tooltip && cd.tooltip.skillName ? cd.tooltip.skillName : (cd.skill ? cd.skill.name : '')}</span>
                            <span class="tooltip-skill-cd">â± ${cd.skill ? cd.skill.cooldown : '?'}ì´ˆ</span>
                        </div>
                        ${skillCoeffHTML2}${cd.tooltip ? cd.tooltip.skill : ''}
                    </div>
                </div>`;
        }

        // ========== ë°© ëª©ë¡ ë’¤ë¡œê°€ê¸° ==========
        document.getElementById('lobbyBackBtn').addEventListener('click', () => {
            if (myPlayerId && playersRef) {
                playersRef.child(myPlayerId).remove().then(() => {
                    if (currentRoomId) {
                        playersRef.once('value', snap => {
                            const rem = snap.val();
                            if (!rem || Object.keys(rem).length === 0) {
                                database.ref('rooms/' + currentRoomId).remove();
                            } else if (isHost) {
                                // ë°©ì¥ì´ ë‚˜ê°€ë©´ timestamp ê¸°ì¤€ ìµœì„ ì„ìì—ê²Œ ë°©ì¥ ì´ì „
                                const arr = Object.values(rem);
                                arr.sort((a, b) => (a.timestamp||0) - (b.timestamp||0));
                                const newHost = arr[0];
                                if (newHost) {
                                    gameStateRef.update({ hostId: newHost.id, hostName: newHost.nickname });
                                }
                            }
                        });
                    }
                });
            }
            playersRef && playersRef.off();
            gameStateRef && gameStateRef.off();
            myPlayerId = null; isHost = false; isReady = false; currentRoomId = null;
            document.getElementById('readyBtn').textContent = 'ì¤€ë¹„ ì™„ë£Œ';
            document.getElementById('readyBtn').style.background = '#00fff5';
            document.getElementById('startBtn').style.display = 'none';
            document.getElementById('practiceBtn').style.display = 'none';
            document.getElementById('hostIndicator').style.display = 'none';
            showScreen('roomScreen');
            startRoomListListener();
        });

        // ========== ìŠ¤í  ìŠ¤ì™€ì´í¼ ==========
        let spellIndex = 0;
        const spellIds = Object.keys(SPELLS);

        function renderSpellSelection() { renderSpellSwiper(); }

        function renderSpellSwiper() {
            const slider = document.getElementById('spellSlider');
            const dotsContainer = document.getElementById('spellDots');
            if (!slider || !dotsContainer) return;
            slider.innerHTML = '';
            dotsContainer.innerHTML = '';

            spellIds.forEach((spellId, index) => {
                const sp = SPELLS[spellId];
                const slide = document.createElement('div');
                slide.className = 'lby-spell-slide';
                const card = document.createElement('div');
                card.className = 'lby-spell-card' + (mySpell === spellId ? ' selected' : '');
                card.innerHTML = `
                    <div class="sc-icon">${sp.icon}</div>
                    <div class="sc-name">${sp.name}</div>
                    <div class="sc-cd">â± ì¿¨íƒ€ì„ ${sp.cooldown}ì´ˆ</div>
                    <div class="sc-desc">${sp.description}</div>`;
                card.addEventListener('click', () => {
                    mySpell = spellId;
                    if (myPlayerId && playersRef) {
                        playersRef.child(myPlayerId).update({ spell: mySpell });
                    }
                    spellCooldownEnd = 0;
                    document.querySelectorAll('.lby-spell-card').forEach(c => c.classList.remove('selected'));
                    card.classList.add('selected');
                });
                slide.appendChild(card);
                slider.appendChild(slide);

                const dot = document.createElement('div');
                dot.className = 'swiper-dot' + (index === 0 ? ' active' : '');
                dot.addEventListener('click', () => goToSpellSlide(index));
                dotsContainer.appendChild(dot);
            });

            // í„°ì¹˜ ìŠ¤ì™€ì´í”„
            let tsX = 0;
            const sw = document.getElementById('spellSwiper');
            sw.addEventListener('touchstart', e => { tsX = e.touches[0].clientX; }, {passive:true});
            sw.addEventListener('touchend', e => {
                const dx = e.changedTouches[0].clientX - tsX;
                if (Math.abs(dx) > 40) {
                    if (dx < 0) goToSpellSlide(spellIndex < spellIds.length - 1 ? spellIndex + 1 : 0);
                    else goToSpellSlide(spellIndex > 0 ? spellIndex - 1 : spellIds.length - 1);
                }
            }, {passive:true});

            document.getElementById('spellSwiperPrev').onclick = () => {
                goToSpellSlide(spellIndex > 0 ? spellIndex - 1 : spellIds.length - 1);
            };
            document.getElementById('spellSwiperNext').onclick = () => {
                goToSpellSlide(spellIndex < spellIds.length - 1 ? spellIndex + 1 : 0);
            };

            const curIdx = spellIds.indexOf(mySpell);
            spellIndex = curIdx >= 0 ? curIdx : 0;
            goToSpellSlide(spellIndex);
        }

        function goToSpellSlide(index) {
            spellIndex = index;
            const slider = document.getElementById('spellSlider');
            if (slider) slider.style.transform = `translateX(-${index * 100}%)`;
            document.querySelectorAll('#spellDots .swiper-dot').forEach((dot, i) => {
                dot.classList.toggle('active', i === index);
            });
            // í™”ì‚´í‘œë¡œ ë„˜ê¸°ëŠ” ê²ƒë§Œìœ¼ë¡œë„ ìŠ¤í  ìë™ ì„ íƒ
            mySpell = spellIds[index];
            if (myPlayerId && playersRef) {
                playersRef.child(myPlayerId).update({ spell: mySpell });
            }
            spellCooldownEnd = 0;
            document.querySelectorAll('.lby-spell-card').forEach((c, i) => {
                c.classList.toggle('selected', i === index);
            });
        }

        // ========== ë°© ëª©ë¡ ë’¤ë¡œê°€ê¸° (ë‹‰ë„¤ì„ í™”ë©´ìœ¼ë¡œ) ==========
        document.getElementById('roomBackBtn').addEventListener('click', () => {
            stopRoomListListener();
            showScreen('nicknameScreen');
        });

        // ========== ë°© ëª©ë¡ ì‹¤ì‹œê°„ ë¦¬ìŠ¤ë„ˆ ==========
        let roomListListener = null;
        function startRoomListListener() {
            if (roomListListener) roomsRef.off('value', roomListListener);
            roomListListener = roomsRef.on('value', (snapshot) => {
                const allRooms = snapshot.val() || {};
                const listDiv = document.getElementById('roomList');
                listDiv.innerHTML = '';

                // â˜… ì˜¤ë˜ëœ/ë¹„ì–´ìˆëŠ” ë£¸ ìë™ ì •ë¦¬ (ë£¸ íŒŒì¼ ëˆ„ì  ë°©ì§€)
                const now = Date.now();
                Object.entries(allRooms).forEach(([roomId, room]) => {
                    const hasPlayers = room.players && Object.keys(room.players).length > 0;
                    const isPlaying = room.gameState && room.gameState.status === GAME_STATUS.PLAYING;
                    const createdAt = room.gameState && room.gameState.createdAt;
                    // í”Œë ˆì´ì–´ê°€ ì—†ëŠ” ë°© ë˜ëŠ” 24ì‹œê°„ ì´ìƒ ëœ ë°© ì‚­ì œ
                    const isStale = createdAt && (now - createdAt > 24 * 60 * 60 * 1000);
                    if (!hasPlayers || isStale) {
                        database.ref('rooms/' + roomId).remove().catch(() => {});
                    }
                });

                const lobbyRooms = Object.entries(allRooms).filter(([, r]) =>
                    r.gameState && r.gameState.status === GAME_STATUS.LOBBY
                    && r.players && Object.keys(r.players).length > 0
                );

                if (lobbyRooms.length === 0) {
                    listDiv.innerHTML = '<div class="room-empty">ëŒ€ê¸° ì¤‘ì¸ ë°©ì´ ì—†ìŠµë‹ˆë‹¤</div>';
                    return;
                }

                lobbyRooms.forEach(([roomId, room]) => {
                    const playerCount = room.players ? Object.keys(room.players).length : 0;
                    const hostName = room.gameState && room.gameState.hostName ? room.gameState.hostName : 'ì•Œ ìˆ˜ ì—†ìŒ';
                    const item = document.createElement('div');
                    item.className = 'room-item';
                    item.innerHTML = `
                        <div class="room-info">
                            <div class="room-host">ğŸ‘‘ ${hostName}ì˜ ë°©</div>
                            <div class="room-count">${playerCount}ëª… ëŒ€ê¸° ì¤‘</div>
                        </div>
                        <div style="color: #00fff5; font-size: 20px;">â€º</div>
                    `;
                    item.addEventListener('click', () => {
                        stopRoomListListener();
                        joinRoom(roomId);
                    });
                    listDiv.appendChild(item);
                });
            });
        }

        function stopRoomListListener() {
            if (roomListListener) {
                roomsRef.off('value', roomListListener);
                roomListListener = null;
            }
        }

        // ========== ë°© ë§Œë“¤ê¸° ë²„íŠ¼ ==========
        document.getElementById('createRoomBtn').addEventListener('click', () => {
            stopRoomListListener();
            const roomId = 'room_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
            joinRoom(roomId, true);
        });

        // ========== ë°© ì…ì¥ (ìƒì„± or ê¸°ì¡´) ==========
        function joinRoom(roomId, isCreating = false) {
            currentRoomId = roomId;
            initRoomRefs(roomId);
            joinLobby(isCreating);
        }

        // ========== ëŒ€ê¸°ì‹¤ ì…ì¥ ==========
        function joinLobby(isCreating = false) {
            myPlayerId = 'player_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            
            // ê²Œì„ ìƒíƒœ í™•ì¸
            gameStateRef.once('value', (snapshot) => {
                const gameState = snapshot.val();
                
                // ê²Œì„ì´ ì§„í–‰ ì¤‘ì´ë©´ ê´€ì „ ëª¨ë“œë¡œ ì…ì¥
                if (gameState && gameState.status === GAME_STATUS.PLAYING) {
                    isSpectating = true;
                    isAlive = false;

                    // Firebaseì— ê´€ì „ìë¡œ ë“±ë¡ (ìœ„ì¹˜ ì—†ì´)
                    const classData = CLASSES[myClass];
                    const spectatorData = {
                        id: myPlayerId,
                        nickname: myNickname,
                        class: myClass,
                        className: classData.name,
                        stats: classData.stats,
                        color: classData.color,
                        ready: false,
                        x: -9999,
                        y: -9999,
                        health: 0,
                        maxHealth: classData.stats.health,
                        isSpectator: true,
                        timestamp: Date.now()
                    };
                    playersRef.child(myPlayerId).set(spectatorData);
                    playersRef.child(myPlayerId).onDisconnect().remove();

                    // ê²Œì„ ì¢…ë£Œ ê°ì§€ â†’ ë¡œë¹„ë¡œ
                    gameStateRef.on('value', (snap) => {
                        const state = snap.val();
                        if (!state || state.status === GAME_STATUS.LOBBY) {
                            location.reload();
                        }
                    });

                    // ê²Œì„ í™”ë©´ìœ¼ë¡œ ì „í™˜ í›„ ê´€ì „ ì‹œì‘
                    gameStatus = GAME_STATUS.PLAYING;
                    showScreen('gameContainer');
                    document.getElementById('info').style.display = 'block';
                    document.getElementById('playerList').style.display = 'block';
                    document.getElementById('controls').style.display = 'block';
                    document.getElementById('myClass').textContent = CLASSES[myClass].name;

                    // í”Œë ˆì´ì–´ ê°ì§€ í›„ ê´€ì „ ëŒ€ìƒ ì„ íƒ
                    playersRef.on('value', (snapshot) => {
                        const data = snapshot.val();
                        for (let id in players) {
                            if (!data || !data[id]) delete players[id];
                        }
                        if (data) {
                            for (let id in data) players[id] = data[id];
                        }
                        updatePlayerList();
                        // ê´€ì „ ëŒ€ìƒì´ ì—†ê±°ë‚˜ ì‚¬ë¼ì¡Œìœ¼ë©´ ìƒˆë¡œ ì„ íƒ
                        if (!spectateTargetId || !players[spectateTargetId] || players[spectateTargetId].isSpectator) {
                            pickRandomSpectateTarget();
                        }
                    });

                    setupInputListeners();
                    setupEffectListeners();
                    if (!_gameLoopRunning) { _gameLoopRunning = true; gameLoop(); }
                    return;
                }
                
                // ëŒ€ê¸°ì‹¤ë¡œ ì…ì¥ - ì§ì—…ì´ ì—†ìœ¼ë©´ ì²« ë²ˆì§¸ ì§ì—…ìœ¼ë¡œ ê¸°ë³¸ ì„¤ì •
                if (!myClass) {
                    lobbyClassIds = Object.keys(CLASSES);
                    lobbyClassIndex = 0;
                    myClass = lobbyClassIds[0];
                }
                const classData = CLASSES[myClass];
                const playerData = {
                    id: myPlayerId,
                    nickname: myNickname,
                    class: myClass,
                    className: classData.name,
                    stats: classData.stats,
                    color: classData.color,
                    spell: mySpell,
                    ready: false,
                    x: 0,
                    y: 0,
                    health: classData.stats.health,
                    maxHealth: classData.stats.health,
                    timestamp: Date.now()
                };
                
                playersRef.child(myPlayerId).set(playerData);
                playersRef.child(myPlayerId).onDisconnect().remove();
                
                // ë°©ì¥ ê²°ì •: ìƒˆ ë°© ìƒì„±ì´ê±°ë‚˜ gameStateì˜ hostIdê°€ ë¹„ì–´ìˆìœ¼ë©´ ë°©ì¥ ìŠ¹ê³„
                gameStateRef.once('value', gSnap => {
                    const gst = gSnap.val();
                    const needHost = isCreating || !gst || !gst.hostId;
                    if (needHost) {
                        isHost = true;
                        gameStateRef.update({
                            status: GAME_STATUS.LOBBY,
                            hostId: myPlayerId,
                            hostName: myNickname,
                            createdAt: Date.now()
                        });
                        if (isCreating) gameStateRef.onDisconnect().remove();
                        document.getElementById('hostIndicator').style.display = 'block';
                        document.getElementById('startBtn').style.display = 'inline-block';
                        document.getElementById('practiceBtn').style.display = 'inline-block';
                    }
                });
                
                showScreen('lobbyScreen');
                // ëŒ€ê¸°ì‹¤ ì§ì—… ì„ íƒ UI ë Œë”ë§
                renderLobbyClassSelection();
                renderSpellSelection();
                // ëŒ€ê¸°ì‹¤ íƒ€ì´í‹€ì— ë°©ì¥ ì´ë¦„ í‘œì‹œ
                gameStateRef.once('value', (s) => {
                    const st = s.val();
                    const hostName = st && st.hostName ? st.hostName : myNickname;
                    document.getElementById('lobbyTitle').textContent = `ğŸ  ${hostName}ì˜ ë°©`;
                });
                setupLobbyListeners();
            });
        }

        // ========== ëŒ€ê¸°ì‹¤ ë¦¬ìŠ¤ë„ˆ ==========
        function setupLobbyListeners() {
            // í”Œë ˆì´ì–´ ëª©ë¡ ê°ì§€
            playersRef.on('value', (snapshot) => {
                const data = snapshot.val();
                if (!data) return;
                
                const listDiv = document.getElementById('lobbyPlayerList');
                listDiv.innerHTML = '';
                
                let readyCount = 0;
                let totalCount = 0;
                
                for (let id in data) {
                    const player = data[id];
                    totalCount++;
                    if (player.ready) readyCount++;
                    
                    const playerDiv = document.createElement('div');
                    playerDiv.className = 'lobby-player';
                    if (player.ready) playerDiv.classList.add('ready');
                    
                    const spellBadge = player.spell && SPELLS[player.spell]
                        ? `<span class="lobby-player-spell-badge">${SPELLS[player.spell].icon} ${SPELLS[player.spell].name}</span>`
                        : `<span style="color:#444;font-size:10px;">â€”</span>`;
                    playerDiv.innerHTML = `
                        <div class="lobby-player-info">
                            <div class="lp-name-row">
                                <div class="player-color" style="background:${player.color};"></div>
                                <span>${player.nickname}</span>
                                ${id === myPlayerId ? '<span style="color:#444;font-size:10px;font-weight:normal;">(ë‚˜)</span>' : ''}
                            </div>
                            <div class="lp-badge-row">
                                <span class="lobby-player-class">${CLASSES[player.class] ? CLASSES[player.class].icon + ' ' : ''}${player.className}</span>
                                ${spellBadge}
                            </div>
                        </div>
                        <span class="lobby-player-status ${player.ready ? 'ready' : 'waiting'}">
                            ${player.ready ? 'âœ“ ì¤€ë¹„' : 'ëŒ€ê¸°'}
                        </span>
                    `;
                    listDiv.appendChild(playerDiv);
                }
                
                document.getElementById('lobbyPlayerCount').textContent = totalCount;
                
                if (isHost && totalCount > 0 && readyCount === totalCount) {
                    document.getElementById('startBtn').disabled = false;
                } else if (isHost) {
                    document.getElementById('startBtn').disabled = true;
                }
            });

            // â˜… íŒŒí‹°ì›ìš©: gameState ë³€ê²½ ê°ì§€ â†’ PLAYING ì „í™˜ & ë°©ì¥ ìŠ¹ê³„ UI
            gameStateRef.on('value', (snapshot) => {
                const state = snapshot.val();
                if (!state) return;
                // ë°©ì¥ ìŠ¹ê³„: hostIdê°€ ë‚´ IDë¡œ ë³€ê²½ë˜ë©´ ë°©ì¥ UI í™œì„±í™”
                if (state.hostId === myPlayerId && !isHost) {
                    isHost = true;
                    document.getElementById('hostIndicator').style.display = 'block';
                    document.getElementById('startBtn').style.display = 'inline-block';
                    document.getElementById('practiceBtn').style.display = 'inline-block';
                    document.getElementById('lobbyTitle').textContent = `ğŸ  ${myNickname}ì˜ ë°©`;
                }
                if (state.status === GAME_STATUS.PLAYING && gameStatus !== GAME_STATUS.PLAYING) {
                    // ìŠ¤í° ì¢Œí‘œê°€ Firebaseì— ë°˜ì˜ë  ë•Œê¹Œì§€ ì ê¹ ëŒ€ê¸° í›„ ì‹œì‘
                    playersRef.child(myPlayerId).once('value', (snap) => {
                        const me = snap.val();
                        if (me && me.x !== undefined && me.x !== 0) {
                            startGame();
                        } else {
                            // ì¢Œí‘œê°€ ì•„ì§ ì•ˆ ì™”ìœ¼ë©´ ì¬ì‹œë„
                            setTimeout(() => {
                                playersRef.child(myPlayerId).once('value', (snap2) => {
                                    startGame();
                                });
                            }, 300);
                        }
                    });
                }
            });
        }

        // ========== ì¤€ë¹„ ì™„ë£Œ ë²„íŠ¼ ==========
        document.getElementById('readyBtn').addEventListener('click', () => {
            if (!myClass) {
                document.getElementById('lobbyClassError').textContent = 'ì§ì—…ì„ ë¨¼ì € ì„ íƒí•´ì£¼ì„¸ìš”!';
                return;
            }
            isReady = !isReady;
            playersRef.child(myPlayerId).update({ ready: isReady });
            document.getElementById('readyBtn').textContent = isReady ? 'ì¤€ë¹„ ì·¨ì†Œ' : 'ì¤€ë¹„ ì™„ë£Œ';
            document.getElementById('readyBtn').style.background = isReady ? '#ff9800' : '#00fff5';
        });

        // ========== ê²Œì„ ì‹œì‘ ë²„íŠ¼ (ì¼ë°˜ ëª¨ë“œ: 2ì¸ ì´ìƒ) ==========
        document.getElementById('startBtn').addEventListener('click', () => {
            if (!isHost) return;
            playersRef.once('value', (snapshot) => {
                const allPlayers = snapshot.val();
                const playerCount = Object.keys(allPlayers || {}).length;
                if (playerCount < 2) {
                    document.getElementById('lobbyError').textContent = 'ì¼ë°˜ ê²Œì„ì€ 2ì¸ ì´ìƒ í•„ìš”í•©ë‹ˆë‹¤. 1ì¸ì€ ì—°ìŠµ ëª¨ë“œë¥¼ ì´ìš©í•˜ì„¸ìš”.';
                    return;
                }
                document.getElementById('lobbyError').textContent = '';
                gameMode = GAME_MODE.NORMAL;
                startGameSession(allPlayers);
            });
        });

        // ========== ì—°ìŠµ ëª¨ë“œ ë²„íŠ¼ ==========
        document.getElementById('practiceBtn').addEventListener('click', () => {
            if (!isHost) return;
            playersRef.once('value', (snapshot) => {
                const allPlayers = snapshot.val();
                gameMode = GAME_MODE.PRACTICE;
                startGameSession(allPlayers);
            });
        });

        // ========== ê²Œì„ ì„¸ì…˜ ì‹œì‘ ê³µí†µ ë¡œì§ ==========
        function startGameSession(allPlayers) {
            const updates = {};
            for (let id in allPlayers) {
                const spawnX = 75 + Math.random() * 1350;
                const spawnY = 75 + Math.random() * 1350;
                updates[id + '/x'] = spawnX;
                updates[id + '/y'] = spawnY;
                updates[id + '/ready'] = false;
            }

            // ì—°ìŠµ ëª¨ë“œë©´ í—ˆìˆ˜ì•„ë¹„ ì¶”ê°€
            if (gameMode === GAME_MODE.PRACTICE) {
                updates[DUMMY_ID] = createDummyData();
            }

            playersRef.update(updates, () => {
                gameStateRef.update({
                    status: GAME_STATUS.PLAYING,
                    mode: gameMode,
                    startTime: Date.now()
                });
                startGame();
            });
        }

        // ========== ê²Œì„ ì‹œì‘ ==========
        function startGame() {
            if (gameStatus === GAME_STATUS.PLAYING) return;
            gameStatus = GAME_STATUS.PLAYING;

            // â˜… Firebaseì—ì„œ ë‚´ ìµœì‹  ìŠ¤í  ë™ê¸°í™” (ëŒ€ê¸°ì‹¤ì—ì„œ ë°”ê¾¼ ìŠ¤í  ë°˜ì˜)
            playersRef.child(myPlayerId).once('value', (snap) => {
                const me = snap.val();
                if (me && me.spell && SPELLS[me.spell]) {
                    mySpell = me.spell;
                }
                spellCooldownEnd = 0; // ê²Œì„ ì‹œì‘ ì‹œ ì¿¨íƒ€ì„ ì´ˆê¸°í™”
                _startGameInner();
            });
        }

        function _startGameInner() {
            playersRef.off();
            gameStateRef.off();
            // ë¦¬ìŠ¤ë„ˆ í”Œë˜ê·¸ ë¦¬ì…‹ â€” ê²Œì„ ì‹œì‘ ì‹œ ì¬ë“±ë¡ í—ˆìš©
            _effectListenersSetup = false;


            // â˜… ë‚´ ì´ì „ ì„¸ì…˜ ì”ì—¬ ë°ì´í„° ì •ë¦¬ (ë¹„ë™ê¸°, ë¸”ë¡œí‚¹ ì—†ìŒ)
            Promise.all([
                bulletsRef.orderByChild('ownerId').equalTo(myPlayerId).once('value').then(s => s.forEach(c => c.ref.remove())),
                particlesRef.orderByChild('ownerId').equalTo(myPlayerId).once('value').then(s => s.forEach(c => c.ref.remove())),
                swingsRef.child(myPlayerId).remove()
            ]).catch(() => {}); // ì—ëŸ¬ ë¬´ì‹œ

            showScreen('gameContainer');
            document.getElementById('info').style.display = 'block';
            document.getElementById('playerList').style.display = 'block';
            document.getElementById('controls').style.display = 'block';
            document.getElementById('myClass').textContent = CLASSES[myClass].name;
            isAlive = true;

            // â˜… ì¢…ë£Œ/ìƒˆë¡œê³ ì¹¨ ì‹œ ìºë¦­í„°(+ì—°ìŠµ ëª¨ë“œëŠ” ë°© ì „ì²´) ì œê±°
            if (gameMode === GAME_MODE.PRACTICE && currentRoomId) {
                // ì—°ìŠµ ëª¨ë“œ: ì ‘ì† ëŠê¸°ë©´ ë°© ì „ì²´ ì‚­ì œ
                database.ref('rooms/' + currentRoomId).onDisconnect().remove();
                window.addEventListener('beforeunload', () => {
                    database.ref('rooms/' + currentRoomId).remove();
                });
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'hidden') {
                        database.ref('rooms/' + currentRoomId).remove();
                    }
                });
            } else {
                // ì¼ë°˜ ê²Œì„ ëª¨ë“œ: í”Œë ˆì´ì–´ ë°ì´í„° ì œê±° + í˜¸ìŠ¤íŠ¸ëŠ” ë°© ì „ì²´ onDisconnect ë“±ë¡
                playersRef.child(myPlayerId).onDisconnect().remove();
                if (isHost && currentRoomId) {
                    // í˜¸ìŠ¤íŠ¸ ì ‘ì† ëŠê¸°ë©´ ë°© ì „ì²´ ì‚­ì œ (ë£¸ íŒŒì¼ ëˆ„ì  ë°©ì§€)
                    database.ref('rooms/' + currentRoomId).onDisconnect().remove();
                }
                window.addEventListener('beforeunload', () => {
                    playersRef.child(myPlayerId).remove();
                    if (isHost && currentRoomId) {
                        database.ref('rooms/' + currentRoomId).remove();
                    }
                });
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState === 'hidden') {
                        playersRef.child(myPlayerId).remove();
                    }
                });
            }

            // ì…ë ¥ ì´ë²¤íŠ¸ (ì¤‘ë³µ ë“±ë¡ ë°©ì§€)
            setupInputListeners();

            // í”Œë ˆì´ì–´ ì‹¤ì‹œê°„ ë™ê¸°í™” + ìŠ¹ë¦¬ ì¡°ê±´ ì²´í¬
            // â”€â”€ ìœ„ì¹˜/ìƒíƒœ ìˆ˜ì‹ : child_changedë¡œ ë¶„ë¦¬ (valueëŠ” ì´ë™ë§ˆë‹¤ ì „ì²´ ì¬ìˆ˜ì‹  â†’ ë©”ì¸ìŠ¤ë ˆë“œ ë¸”ë¡œí‚¹)
            playersRef.on('child_added', snap => {
                const d = snap.val(); if (d) players[snap.key] = d;
                if (d && snap.key !== myPlayerId && d.x !== undefined) {
                    playerRenderPos[snap.key] = { x: d.x, y: d.y, tx: d.x, ty: d.y };
                }
                updatePlayerList();
            });
            playersRef.on('child_removed', snap => {
                delete players[snap.key];
                delete playerRenderPos[snap.key];
                updatePlayerList();
            });
            playersRef.on('child_changed', snap => {
                const id = snap.key;
                const d = snap.val();
                if (!d) return;
                // ìœ„ì¹˜ë§Œ ê°±ì‹ í•˜ë©´ ë˜ëŠ” ê²½ìš° Object.assignìœ¼ë¡œ ìµœì†Œ ë³µì‚¬
                if (players[id]) Object.assign(players[id], d);
                else players[id] = d;
                // ë‹¤ë¥¸ í”Œë ˆì´ì–´ ë³´ê°„ ëª©í‘œ ê°±ì‹  + dead-reckoning (ë‚´ í”Œë ˆì´ì–´ ì œì™¸)
                if (id !== myPlayerId && d.x !== undefined && d.y !== undefined) {
                    const _now_dr = Date.now();
                    if (!playerRenderPos[id]) {
                        playerRenderPos[id] = { x: d.x, y: d.y, tx: d.x, ty: d.y, vx: 0, vy: 0, lastT: _now_dr };
                    } else {
                        const rp = playerRenderPos[id];
                        const dt = Math.max(1, _now_dr - (rp.lastT || _now_dr));
                        // ì†ë„ ë²¡í„° ê³„ì‚° (í”½ì…€/ms)
                        rp.vx = (d.x - rp.tx) / dt;
                        rp.vy = (d.y - rp.ty) / dt;
                        rp.lastT = _now_dr;
                        rp.tx = d.x;
                        rp.ty = d.y;
                    }
                }

                // ê´€ì „ ëŒ€ìƒ ê°±ì‹ 
                if ((isSpectating || !isAlive) && (!spectateTargetId || !players[spectateTargetId] || players[spectateTargetId].isSpectator)) {
                    pickRandomSpectateTarget();
                }

                // ìŠ¹ë¦¬ ì¡°ê±´ ì²´í¬ (HP/isSpectator ë³€ê²½ ì‹œì—ë§Œ ì˜ë¯¸ ìˆìŒ)
                if (gameMode === GAME_MODE.NORMAL && (d.health !== undefined || d.isSpectator !== undefined)) {
                    const alivePlayers = Object.keys(players).filter(pid =>
                        pid !== DUMMY_ID && !players[pid].isSpectator && players[pid].health > 0
                    );
                    const totalPlayers = Object.keys(players).filter(pid => pid !== DUMMY_ID).length;
                    if (alivePlayers.length === 1 && totalPlayers >= 2) {
                        const winner = players[alivePlayers[0]];
                        if (winner) showVictoryScreen(winner.nickname);
                    }
                }
            });

            // ë‚´ HP ë³€ê²½ ê°ì§€ â†’ ì‚¬ë§ ì²˜ë¦¬ / ì—°ìŠµ ëª¨ë“œ ë¶€í™œ
            playersRef.child(myPlayerId).on('value', (snapshot) => {
                const data = snapshot.val();
                if (!data) return;

                // â˜… ëª¨ë˜ì‹œê³„ ë¬´ì : ë³¸ì¸ì´ hourglassActive ì¤‘ì´ë©´ HP ë³€í™” ë¬´íš¨
            if (hourglassActive && data.health < (players[myPlayerId] ? players[myPlayerId].maxHealth || CLASSES[myClass].stats.health : 999)) {
                // í”¼í•´ë¥¼ ë°›ì•˜ìœ¼ë©´ ì¦‰ì‹œ ë³µêµ¬
                const maxHp = players[myPlayerId] ? (players[myPlayerId].maxHealth || CLASSES[myClass].stats.health) : CLASSES[myClass].stats.health;
                if (data.health < maxHp) {
                    // ëª¨ë˜ì‹œê³„ ì¤‘ í”¼í•´ ë¬´íš¨ â€” HP ì›ìƒë³µêµ¬
                    playersRef.child(myPlayerId).update({ health: maxHp });
                    return;
                }
            }
            if (data.health <= 0 && isAlive) {
                    isAlive = false;
                    cancelSamuraiCharge(); // ì‚¬ë¬´ë¼ì´ ì°¨ì§• ì·¨ì†Œ

                    if (gameMode === GAME_MODE.PRACTICE) {
                        // ì—°ìŠµ ëª¨ë“œ: 1ì´ˆ í›„ ë¶€í™œ
                        setTimeout(() => {
                            const respawnX = 75 + Math.random() * 1350;
                            const respawnY = 75 + Math.random() * 1350;
                            const maxHp = myClass === 'blacksmith' ? CLASSES.blacksmith.stats.health : CLASSES[myClass].stats.health;
                            playersRef.child(myPlayerId).update({
                                x: respawnX,
                                y: respawnY,
                                health: maxHp,
                                isSpectator: false
                            });
                            isAlive = true;
                            isSpectating = false;
                            jumongHawkeyeActive = false;
                            muhuiZoneActive = false;
                            document.getElementById('spectateHint').style.display = 'none';
                        }, 1000);
                    } else {
                        // ì¼ë°˜ ëª¨ë“œ: ê´€ì „
                        isSpectating = true;
                        pickRandomSpectateTarget();
                        document.getElementById('spectateHint').style.display = 'block';
                    }
                }
            });

            // ë‹¤ë¥¸ í”Œë ˆì´ì–´ ì´ì•Œ/íŒŒí‹°í´/ì´í™íŠ¸ ìˆ˜ì‹  (ê³µí†µ)
            setupEffectListeners();

            // ê²Œì„ ê°•ì œì¢…ë£Œ ê°ì§€ + ê²Œì„ ëª¨ë“œ ë™ê¸°í™”
            gameStateRef.on('value', (snapshot) => {
                const state = snapshot.val();
                if (!state || state.status === GAME_STATUS.LOBBY) {
                    // victoryShown=trueë©´ ìŠ¹ë¦¬ í™”ë©´ì´ ì§ì ‘ ë³µê·€ ì²˜ë¦¬ ì¤‘ â€” reload ë¶ˆí•„ìš”
                    if (!victoryShown) location.reload();
                    return;
                }
                if (state.mode) gameMode = state.mode;
            });



            // ë‚˜ê°€ê¸° ë²„íŠ¼ (ëŒ€ê¸°ì‹¤ë¡œ)
            document.getElementById('exitToLobbyBtn').onclick = () => {
                if (!confirm('ê²Œì„ì„ ë‚˜ê°€ê³  ëŒ€ê¸°ì‹¤ë¡œ ëŒì•„ê°ˆê¹Œìš”?')) return;

                const savedRoom = currentRoomId;
                const savedClass = myClass;
                const savedSpell = mySpell;
                const wasPractice = (gameMode === GAME_MODE.PRACTICE);

                // â‘  ë¦¬ìŠ¤ë„ˆ ë¨¼ì € í•´ì œ
                _effectListenersSetup = false;
                _inputListenersSetup = false;
                _gameLoopRunning = false;
                try { playersRef && playersRef.off(); } catch(e) {}
                try { gameStateRef && gameStateRef.off(); } catch(e) {}
                try { bulletsRef && bulletsRef.off(); } catch(e) {}
                try { particlesRef && particlesRef.off(); } catch(e) {}
                try { swingsRef && swingsRef.off(); } catch(e) {}
                try { stabsRef && stabsRef.off(); } catch(e) {}
                try { smokesRef && smokesRef.off(); } catch(e) {}
                try { hitEffectsRef && hitEffectsRef.off(); } catch(e) {}
                try { spellEffectsRef && spellEffectsRef.off(); } catch(e) {}
                document.removeEventListener('keydown', handleKeyDown);
                document.removeEventListener('keyup', handleKeyUp);
                canvas.removeEventListener('mousemove', handleMouseMove);
                canvas.removeEventListener('mousedown', handleMouseDown);
                canvas.removeEventListener('mouseup', handleMouseUp);
                canvas.removeEventListener('contextmenu', handleRightClick);

                // â‘¡ ë‚´ í”Œë ˆì´ì–´ ë°ì´í„° ì‚­ì œ (ì—°ìŠµëª¨ë“œëŠ” ë°© ì „ì²´ ì‚­ì œ)
                if (wasPractice && savedRoom) {
                    database.ref('rooms/' + savedRoom).remove();
                } else if (myPlayerId && playersRef) {
                    try { playersRef.child(myPlayerId).remove(); } catch(e) {}
                }

                // â‘¢ ìƒíƒœ ì´ˆê¸°í™”
                myPlayerId = null;
                isHost = false;
                isReady = false;
                isSpectating = false;
                isAlive = true;
                gameStatus = GAME_STATUS.LOBBY;
                lobbyClassIndex = 0;
                myClass = savedClass;
                mySpell = savedSpell;
                healActive = false; healTicks = 0;
                rageActive = false; rageEnd = 0;
                fluidActive = false; fluidBonus = 0;
                hourglassActive = false; hourglassEnd = 0;
                spellCooldownEnd = 0;
                isDashing = false; dashRemainFrames = 0;
                smithEnhanceLevel = 0; smithForging = false;
                CLASSES.blacksmith.stats = { moveSpeed: 4, attack: 10, attackSpeed: 0.5, health: 80 };
                jumongHawkeyeActive = false; muhuiZoneActive = false;
                bullets.length = 0; bulletIds.clear();
                particles.length = 0; particleIds.clear();
                hitEffects.length = 0;
                for (const k in players) delete players[k];
                for (const k in playerRenderPos) delete playerRenderPos[k];

                document.getElementById('info').style.display = 'none';
                document.getElementById('playerList').style.display = 'none';
                document.getElementById('controls').style.display = 'none';
                document.getElementById('readyBtn').textContent = 'ì¤€ë¹„ ì™„ë£Œ';
                document.getElementById('readyBtn').style.background = '#00fff5';
                document.getElementById('startBtn').style.display = 'none';
                document.getElementById('practiceBtn').style.display = 'none';
                document.getElementById('hostIndicator').style.display = 'none';

                if (!wasPractice && savedRoom) {
                    // â‘£ ê°™ì€ ë°© ëŒ€ê¸°ì‹¤ë¡œ ë³µê·€ â€” ê²Œì„ ì”ì—¬ ë°ì´í„° ì •ë¦¬
                    currentRoomId = savedRoom;
                    initRoomRefs(savedRoom);
                    Promise.all([
                        database.ref('rooms/' + savedRoom + '/bullets').remove(),
                        database.ref('rooms/' + savedRoom + '/particles').remove(),
                        database.ref('rooms/' + savedRoom + '/swings').remove(),
                        database.ref('rooms/' + savedRoom + '/stabs').remove(),
                        database.ref('rooms/' + savedRoom + '/smokes').remove(),
                        database.ref('rooms/' + savedRoom + '/hitEffects').remove(),
                        database.ref('rooms/' + savedRoom + '/spellEffects').remove(),
                        database.ref('rooms/' + savedRoom + '/samuraiSlashes').remove(),
                        database.ref('rooms/' + savedRoom + '/smithHammers').remove(),
                        database.ref('rooms/' + savedRoom + '/jumongArrows').remove(),
                        database.ref('rooms/' + savedRoom + '/muhuiZones').remove(),
                        database.ref('rooms/' + savedRoom + '/parryHits').remove(),
                    ]).catch(() => {});
                    gameStateRef.update({ status: GAME_STATUS.LOBBY, hostId: null, hostName: null })
                        .then(() => joinLobby(false))
                        .catch(() => joinLobby(false));
                } else {
                    // ì—°ìŠµëª¨ë“œëŠ” ìƒˆ ë°©ì„ ë§Œë“¤ì–´ ëŒ€ê¸°ì‹¤ë¡œ ë³µê·€
                    const newRoomId = 'room_' + Date.now() + '_' + Math.random().toString(36).substr(2, 5);
                    joinRoom(newRoomId, true);
                }
            };

            // ê²Œì„ ë£¨í”„ ì‹œì‘ (ì¤‘ë³µ ë°©ì§€)
            if (!_gameLoopRunning) { _gameLoopRunning = true; gameLoop(); }
        }

        // ========== ì´í™íŠ¸ Firebase ë¦¬ìŠ¤ë„ˆ (í”Œë ˆì´ì–´/ê´€ì „ì ê³µí†µ) ==========
        let _effectListenersSetup = false;
        let _inputListenersSetup = false;
        function setupInputListeners() {
            if (_inputListenersSetup) return;
            _inputListenersSetup = true;
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('contextmenu', handleRightClick);
        }
        function setupEffectListeners() {
            if (_effectListenersSetup) return; // ì¤‘ë³µ ë“±ë¡ ë°©ì§€
            _effectListenersSetup = true;
            // â”€â”€ ì´ì•Œ ìˆ˜ì‹  (ìœ„ì¹˜ ê²½ê³¼ì‹œê°„ ë³´ì •) â”€â”€
            bulletsRef.on('child_added', (snapshot) => {
                const b = snapshot.val();
                if (!b || b.ownerId === myPlayerId) return;
                if (bulletIds.has(b.id)) return;
                const elapsed = (Date.now() - b.createdAt) / 1000;
                if (elapsed * 1000 > b.maxLifetime + 500) return;
                const frames = elapsed * 60;
                b.x += b.vx * frames;
                b.y += b.vy * frames;
                bulletIds.add(b.id);
                bullets.push(b);
            });
            bulletsRef.on('child_removed', (snapshot) => {
                const b = snapshot.val();
                if (!b) return;
                bulletIds.delete(b.id);
                const idx = bullets.findIndex(x => x.id === b.id);
                if (idx !== -1) bullets.splice(idx, 1);
            });

            // â”€â”€ íŒŒí‹°í´ ìˆ˜ì‹  (ê²½ê³¼ì‹œê°„ ë³´ì •) â”€â”€
            particlesRef.on('child_added', (snapshot) => {
                const p = snapshot.val();
                if (!p || p.ownerId === myPlayerId) return;
                if (particleIds.has(p.id)) return;
                const elapsed = (Date.now() - p.createdAt) / 1000;
                const framesElapsed = Math.min(30, elapsed * 60);
                p.life = Math.max(0, 1.0 - p.decay * framesElapsed);
                if (p.life <= 0) return;
                p.x += p.vx * framesElapsed;
                p.y += p.vy * framesElapsed;
                particleIds.add(p.id);
                particles.push(p);
            });
            particlesRef.on('child_removed', (snapshot) => {
                const p = snapshot.val();
                if (!p) return;
                particleIds.delete(p.id);
                const idx = particles.findIndex(x => x.id === p.id);
                if (idx !== -1) particles.splice(idx, 1);
            });

            // â”€â”€ íˆíŠ¸ ì´í™íŠ¸ ìˆ˜ì‹  â”€â”€
            hitEffectsRef.on('child_added', (snapshot) => {
                const ef = snapshot.val();
                if (!ef) return;
                if (ef.ownerId === myPlayerId) return; // ë°œì‚¬ìëŠ” ì´ë¯¸ ë¡œì»¬ ìƒì„±
                if (Date.now() - ef.createdAt > 4000) return;
                _addHitEffect(ef);
                // í”¼ê²© í”Œë˜ì‹œ (ë‚´ê°€ ë§ì€ ìœ„ì¹˜ ê·¼ì²˜ë©´)
                if (players[myPlayerId]) {
                    const me = players[myPlayerId];
                    const dx = ef.x - (me.x + PLAYER_SIZE / 2);
                    const dy = ef.y - (me.y + PLAYER_SIZE / 2);
                    if (Math.sqrt(dx*dx + dy*dy) < PLAYER_SIZE) {
                        flashScreen(ef.isFatal ? '#ff000055' : '#ff880033', ef.isFatal ? 300 : 150);
                    }
                }
            });

            // â”€â”€ ì›Œë¦¬ì–´ ìŠ¤ìœ™ ìˆ˜ì‹  â”€â”€
            swingsRef.on('child_added', (snapshot) => {
                const s = snapshot.val();
                if (!s || s.ownerId === myPlayerId) return;
                if (Date.now() - s.createdAt > 4000) return;
                playerSwings[s.ownerId] = {
                    ...s,
                    frames: s.totalFrames,
                    angle: s.dir - s.arc / 2
                };
            });
            swingsRef.on('child_removed', (snapshot) => {
                const s = snapshot.val();
                if (s) delete playerSwings[s.ownerId];
            });

            // â”€â”€ ì–´ìŒ”ì‹  ì°Œë¥´ê¸° ìˆ˜ì‹  â”€â”€
            stabsRef.on('child_added', (snapshot) => {
                const s = snapshot.val();
                if (!s || s.ownerId === myPlayerId) return;
                if (Date.now() - s.createdAt > 4000) return;
                playerStabs[s.ownerId] = { ...s, frames: s.totalFrames };
            });
            stabsRef.on('child_removed', (snapshot) => {
                const s = snapshot.val();
                if (s) delete playerStabs[s.ownerId];
            });

            // â”€â”€ ì–´ìŒ”ì‹  ì—°ê¸° ìˆ˜ì‹  â”€â”€
            smokesRef.on('child_added', (snapshot) => {
                const s = snapshot.val();
                if (!s || s.ownerId === myPlayerId) return;
                // forge_ ì ‘ë‘ì‚¬ëŠ” ê°•í™” ì‹ í˜¸ â€” particlesRefë¡œ ì´ë¯¸ íŒŒí‹°í´ ê³µìœ ë˜ë¯€ë¡œ ì—¬ê¸°ì„  ë¬´ì‹œ
                if (snapshot.key && snapshot.key.startsWith('forge_')) return;
                if (Date.now() - s.createdAt > 3000) return;
                spawnSmokeEffect(s.x, s.y);
            });

            // â”€â”€ ëŒ€ì¥ì¥ì´ ë§ì¹˜ ê³µê²© ìˆ˜ì‹  â”€â”€
            smithHammersRef.on('child_added', (snapshot) => {
                const h = snapshot.val();
                if (!h || h.ownerId === myPlayerId) return;
                if (Date.now() - h.createdAt > 4000) return;
                playerHammers[h.ownerId] = { ...h, frames: h.totalFrames };
            });
            smithHammersRef.on('child_removed', (snapshot) => {
                const h = snapshot.val();
                if (h) delete playerHammers[h.ownerId];
            });

            // â”€â”€ ì‚¬ë¬´ë¼ì´ íŒ¨ë§ íˆíŠ¸ ì‹ í˜¸ ìˆ˜ì‹  (í”¼ê²©ì ë³¸ì¸ë§Œ ì²˜ë¦¬) â”€â”€
            parryHitsRef.on('child_added', (snapshot) => {
                const d = snapshot.val();
                if (!d || d.targetId !== myPlayerId) return;
                if (Date.now() - d.createdAt > 1500) return;
                _checkAndTriggerParry();
            });
            // â”€â”€ ì£¼ëª½ í™”ì‚´ ì‹œê° ì´í™íŠ¸ ìˆ˜ì‹  â”€â”€
            jumongArrowsRef.on('child_added', (snapshot) => {
                const a = snapshot.val();
                if (!a || a.ownerId === myPlayerId) return;
                if (Date.now() - a.createdAt > 3000) return;
                playerJumongArrows[a.id] = { ...a, life: 1.0 };
            });
            jumongArrowsRef.on('child_removed', (snapshot) => {
                const a = snapshot.val();
                if (a) delete playerJumongArrows[a.id];
            });

            // â”€â”€ ë¬´í¬ ì¥íŒ ìˆ˜ì‹  â”€â”€
            muhuiZonesRef.on('child_added', (snapshot) => {
                const z = snapshot.val();
                if (!z || z.ownerId === myPlayerId) return;
                if (Date.now() - z.createdAt > z.duration + 500) return;
                playerMuhuiZones[z.ownerId] = { ...z };
            });
            muhuiZonesRef.on('child_changed', (snapshot) => {
                const z = snapshot.val();
                if (!z || z.ownerId === myPlayerId) return;
                if (playerMuhuiZones[z.ownerId]) {
                    playerMuhuiZones[z.ownerId].x = z.x;
                    playerMuhuiZones[z.ownerId].y = z.y;
                }
            });
            muhuiZonesRef.on('child_removed', (snapshot) => {
                const z = snapshot.val();
                if (z) delete playerMuhuiZones[z.ownerId];
            });

            samuraiSlashesRef.on('child_added', (snapshot) => {
                const s = snapshot.val();
                if (!s || s.ownerId === myPlayerId) return;
                if (Date.now() - s.createdAt > 4000) return;
                const key = snapshot.key;
                playerSamuraiSlashes[key] = {
                    ...s,
                    frames: s.totalFrames || SAMURAI_SLASH_TOTAL,
                    progress: 0,
                    type: s.type || 'slash'
                };
            });
            samuraiSlashesRef.on('child_removed', (snapshot) => {
                delete playerSamuraiSlashes[snapshot.key];
            });

            // â”€â”€ ìŠ¤í  ì´í™íŠ¸ ìˆ˜ì‹  â”€â”€
            spellEffectsRef.on('child_added', (snapshot) => {
                const ef = snapshot.val();
                if (!ef || ef.ownerId === myPlayerId) return;
                if (Date.now() - ef.createdAt > 5000) return;
                playerSpellEffects[ef.ownerId] = { ...ef, localStartedAt: Date.now() };
            });
            spellEffectsRef.on('child_removed', (snapshot) => {
                const ef = snapshot.val();
                if (ef) delete playerSpellEffects[ef.ownerId];
            });
        }

        // ========== ìŠ¹ë¦¬ í™”ë©´ ==========
        let victoryShown = false; // ì¤‘ë³µ í˜¸ì¶œ ë°©ì§€
        function showVictoryScreen(winnerName) {
            if (victoryShown) return;
            victoryShown = true;

            const isWinner = players[myPlayerId] && players[myPlayerId].health > 0 && !players[myPlayerId].isSpectator;
            const msg = isWinner ? `ğŸ‰ ${myNickname} ìŠ¹ë¦¬! ğŸ‰` : `ğŸ† ${winnerName} ë‹˜ì´ ìŠ¹ë¦¬í–ˆìŠµë‹ˆë‹¤!`;

            const overlay = document.createElement('div');
            overlay.id = 'victoryOverlay';
            overlay.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.85); display: flex; flex-direction: column;
                justify-content: center; align-items: center; z-index: 9999; pointer-events: auto;
            `;
            overlay.innerHTML = `
                <div style="text-align:center;">
                    <div style="font-size:56px; font-weight:bold; color:${isWinner ? '#ffd700' : '#00fff5'};
                        text-shadow:0 0 30px ${isWinner ? '#ffd700' : '#00fff5'}; margin-bottom:30px;">
                        ${msg}
                    </div>
                    <div id="victoryCountdown" style="color:#aaa; font-size:18px; margin-bottom:40px;">
                        5ì´ˆ í›„ ìë™ìœ¼ë¡œ ëŒ€ê¸°ì‹¤ë¡œ ì´ë™í•©ë‹ˆë‹¤...
                    </div>
                    <button id="victoryReplayBtn" style="padding:15px 35px; background:#00fff5; color:#16213e;
                        border:none; border-radius:8px; font-size:18px; font-weight:bold; cursor:pointer;">
                        ì¦‰ì‹œ ëŒ€ê¸°ì‹¤ë¡œ
                    </button>
                </div>
            `;
            document.body.appendChild(overlay);

            // ì¹´ìš´íŠ¸ë‹¤ìš´
            let remaining = 5;
            const countdownEl = document.getElementById('victoryCountdown');
            const tickInterval = setInterval(() => {
                remaining--;
                if (remaining > 0) {
                    countdownEl.textContent = `${remaining}ì´ˆ í›„ ìë™ìœ¼ë¡œ ëŒ€ê¸°ì‹¤ë¡œ ì´ë™í•©ë‹ˆë‹¤...`;
                } else {
                    clearInterval(tickInterval);
                }
            }, 1000);

            let going = false;
            function goToLobby() {
                if (going) return;
                going = true;
                clearInterval(tickInterval);
                clearTimeout(autoTimer);

                // â‘  ëª¨ë“  Firebase ë¦¬ìŠ¤ë„ˆ í•´ì œ (location.reload íŠ¸ë¦¬ê±° ë°©ì§€)
                _effectListenersSetup = false; _inputListenersSetup = false; _gameLoopRunning = false;
                try { playersRef && playersRef.off(); } catch(e) {}
                try { gameStateRef && gameStateRef.off(); } catch(e) {}
                try { bulletsRef && bulletsRef.off(); } catch(e) {}
                try { particlesRef && particlesRef.off(); } catch(e) {}
                try { swingsRef && swingsRef.off(); } catch(e) {}
                try { stabsRef && stabsRef.off(); } catch(e) {}
                try { smokesRef && smokesRef.off(); } catch(e) {}
                try { hitEffectsRef && hitEffectsRef.off(); } catch(e) {}
                try { spellEffectsRef && spellEffectsRef.off(); } catch(e) {}

                // â‘¡ í‚¤/ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ í•´ì œ
                document.removeEventListener('keydown', handleKeyDown);
                document.removeEventListener('keyup', handleKeyUp);
                canvas.removeEventListener('mousemove', handleMouseMove);
                canvas.removeEventListener('mousedown', handleMouseDown);
                canvas.removeEventListener('mouseup', handleMouseUp);
                canvas.removeEventListener('contextmenu', handleRightClick);

                // â‘¢ ë‚´ í”Œë ˆì´ì–´ ë°ì´í„°ë§Œ ì‚­ì œ (ë¦¬ìŠ¤ë„ˆ off í›„ì— ì‹¤í–‰)
                const _pid = myPlayerId;
                if (_pid && playersRef) {
                    try { playersRef.child(_pid).remove(); } catch(e) {}
                }

                // â‘£ ë¡œì»¬ ìƒíƒœ ì´ˆê¸°í™” (ë°© IDÂ·ë‹‰ë„¤ì„Â·ì§ì—…Â·ìŠ¤í  ìœ ì§€)
                const savedRoom = currentRoomId;
                const savedClass = myClass;
                const savedSpell = mySpell;
                myPlayerId = null;
                isHost = false;
                isReady = false;
                isSpectating = false;
                isAlive = true;
                gameStatus = GAME_STATUS.LOBBY;
                victoryShown = false;
                lobbyClassIndex = 0;
                myClass = savedClass;
                mySpell = savedSpell;
                healActive = false; healTicks = 0;
                rageActive = false; rageEnd = 0;
                fluidActive = false; fluidBonus = 0;
                hourglassActive = false; hourglassEnd = 0;
                spellCooldownEnd = 0;
                isDashing = false; dashRemainFrames = 0;
                smithEnhanceLevel = 0; smithForging = false;
                CLASSES.blacksmith.stats = { moveSpeed: 4, attack: 10, attackSpeed: 0.5, health: 80 };
                jumongHawkeyeActive = false; muhuiZoneActive = false;
                bullets.length = 0; bulletIds.clear();
                particles.length = 0; particleIds.clear();
                hitEffects.length = 0;
                for (const k in players) delete players[k];
                for (const k in playerRenderPos) delete playerRenderPos[k];
                for (const k in playerSwings) delete playerSwings[k];
                for (const k in playerStabs) delete playerStabs[k];
                for (const k in playerSpellEffects) delete playerSpellEffects[k];

                // â‘¤ HUDÂ·ì˜¤ë²„ë ˆì´ ì •ë¦¬
                try { overlay.remove(); } catch(e) {}
                document.getElementById('info').style.display = 'none';
                document.getElementById('playerList').style.display = 'none';
                document.getElementById('controls').style.display = 'none';
                document.getElementById('readyBtn').textContent = 'ì¤€ë¹„ ì™„ë£Œ';
                document.getElementById('readyBtn').style.background = '#00fff5';
                document.getElementById('startBtn').style.display = 'none';
                document.getElementById('practiceBtn').style.display = 'none';
                document.getElementById('hostIndicator').style.display = 'none';

                if (savedRoom) {
                    // â‘¥ ê°™ì€ ë°© ëŒ€ê¸°ì‹¤ë¡œ ë³µê·€ â€” ê²Œì„ ì”ì—¬ ë°ì´í„° ì •ë¦¬ í›„ ì¬ì…ì¥
                    currentRoomId = savedRoom;
                    initRoomRefs(savedRoom);
                    // ê²Œì„ ì¤‘ ìƒì„±ëœ Firebase ì„œë¸Œë…¸ë“œ ì¼ê´„ ì •ë¦¬ (ë£¸ íŒŒì¼ ëˆ„ì  ë°©ì§€)
                    Promise.all([
                        database.ref('rooms/' + savedRoom + '/bullets').remove(),
                        database.ref('rooms/' + savedRoom + '/particles').remove(),
                        database.ref('rooms/' + savedRoom + '/swings').remove(),
                        database.ref('rooms/' + savedRoom + '/stabs').remove(),
                        database.ref('rooms/' + savedRoom + '/smokes').remove(),
                        database.ref('rooms/' + savedRoom + '/hitEffects').remove(),
                        database.ref('rooms/' + savedRoom + '/spellEffects').remove(),
                        database.ref('rooms/' + savedRoom + '/samuraiSlashes').remove(),
                        database.ref('rooms/' + savedRoom + '/smithHammers').remove(),
                        database.ref('rooms/' + savedRoom + '/jumongArrows').remove(),
                        database.ref('rooms/' + savedRoom + '/muhuiZones').remove(),
                        database.ref('rooms/' + savedRoom + '/parryHits').remove(),
                    ]).catch(() => {});
                    // gameState LOBBY ë¦¬ì…‹ í›„ ëŒ€ê¸°ì‹¤ ì¬ì…ì¥
                    gameStateRef.update({ status: GAME_STATUS.LOBBY, hostId: null, hostName: null })
                        .then(() => joinLobby(false))
                        .catch(() => joinLobby(false));
                } else {
                    showScreen('roomScreen');
                    startRoomListListener();
                }
            }

            document.getElementById('victoryReplayBtn').addEventListener('click', goToLobby);
            let autoTimer = setTimeout(goToLobby, 5000);
        }

        function handleKeyDown(e) {
            const key = e.key.toLowerCase();
            keys[key] = true;

            // Tab: í—ˆìˆ˜ì•„ë¹„ ì¸¡ì • ì´ˆê¸°í™”
            if (e.key === 'Tab' && gameMode === GAME_MODE.PRACTICE) {
                e.preventDefault();
                dummyDmgTotal = 0;
                dummyDmgWindow = [];
                dummyDps = 0;
                dummyLastHit = 0;
                dummyFloatingNums = [];
            }
            
            // Shift â†’ ìŠ¤í  ì‚¬ìš©
            if (key === 'shift' && !keys['shift_pressed']) {
                keys['shift_pressed'] = true;
                if (!isSpectating && isAlive && !hourglassActive) {
                    performSpell();
                }
            }
            
            // Rí‚¤ í™€ë“œ ì‹œì‘ (ëˆ„êµ¬ë‚˜ 3ì´ˆ í™€ë“œ ì‹œ ê°•ì œì¢…ë£Œ)
            if (key === 'r' && gameStatus === GAME_STATUS.PLAYING && !rKeyHolding) {
                rKeyHolding = true;
                rKeyPressStart = Date.now();
            }
        }

        function handleKeyUp(e) {
            const key = e.key.toLowerCase();
            keys[key] = false;
            
            if (key === 'shift') {
                keys['shift_pressed'] = false;
            }

            // Rí‚¤ ë—Œ â†’ ì´ˆê¸°í™”
            if (key === 'r') {
                rKeyHolding = false;
                rKeyPressStart = 0;
                forceStopProgress = 0;
            }
        }

        // ========== ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ ==========
        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        }

        // â”€â”€ ì‚¬ë¬´ë¼ì´ ì°¨ì§• ì·¨ì†Œ (ì£½ìŒ/íŒ¨ë§ ë“±) â”€â”€
        function cancelSamuraiCharge() {
            if (!samuraiCharging) return;
            samuraiCharging = false;
            if (myPlayerId) playersRef.child(myPlayerId).update({ samuraiCharging: false });
        }

        // â”€â”€ ë¬´í¬ ì¥íŒ ê°•ì œ ì¢…ë£Œ â”€â”€
        function cancelMuhuiZone() {
            if (!muhuiZoneActive) return;
            muhuiZoneActive = false;
            if (myPlayerId) {
                muhuiZonesRef.child(myPlayerId).remove();
                delete playerMuhuiZones[myPlayerId];
                playersRef.child(myPlayerId).update({ muhuiZone: false });
            }
        }

        // â”€â”€ ì‚¬ë¬´ë¼ì´ ì°¨ì§• ë°œì‚¬ ê³µí†µ í•¨ìˆ˜ â”€â”€
        function fireSamuraiThrust() {
            if (!samuraiCharging) return;
            samuraiCharging = false;
            // Firebase ì°¨ì§• ìƒíƒœ í•´ì œ
            if (myPlayerId) playersRef.child(myPlayerId).update({ samuraiCharging: false });
            if (samuraiSlashActive || samuraiParryActive || samuraiCounterActive) return;
            if (!myPlayerId || !players[myPlayerId]) return;
            const now = Date.now();
            const chargedMs = Math.min(now - samuraiChargeStart, SAMURAI_MAX_CHARGE);
            // ë ˆë²¨ ê²°ì •
            let lvl = SAMURAI_CHARGE_LEVELS[0];
            for (const l of SAMURAI_CHARGE_LEVELS) {
                if (chargedMs >= l.minTime) lvl = l;
            }
            samuraiCurrentLevel = lvl;
            // â˜… ë°œì‚¬ ìˆœê°„ì˜ ë§ˆìš°ìŠ¤ ë°©í–¥ìœ¼ë¡œ ì¬ê³„ì‚°
            const myPlayer = players[myPlayerId];
            const worldMouseX = mouseX + cameraX;
            const worldMouseY = mouseY + cameraY;
            const fdx = worldMouseX - (myPlayer.x + PLAYER_SIZE / 2);
            const fdy = worldMouseY - (myPlayer.y + PLAYER_SIZE / 2);
            samuraiSlashDir = Math.atan2(fdy, fdx);
            samuraiSlashProgress = 0;
            samuraiSlashActive = true;
            samuraiSlashFrames = SAMURAI_SLASH_TOTAL;
            samuraiSlashHitIds.clear();
            samuraiSlashDashFrames = lvl.dashFrames;
            samuraiSlashDashVx = Math.cos(samuraiSlashDir) * lvl.dashSpeed;
            samuraiSlashDashVy = Math.sin(samuraiSlashDir) * lvl.dashSpeed;
            const slashData = {
                ownerId: myPlayerId,
                dir: samuraiSlashDir,
                totalFrames: SAMURAI_SLASH_TOTAL,
                thrustLength: lvl.length,
                thrustWidth: lvl.width,
                createdAt: now,
                ox: myPlayer.x + PLAYER_SIZE / 2,
                oy: myPlayer.y + PLAYER_SIZE / 2
            };
            samuraiSlashesRef.child(myPlayerId).set(slashData);
            playerSamuraiSlashes[myPlayerId] = { ...slashData, frames: SAMURAI_SLASH_TOTAL, progress: 0 };
            lastAttackTime = now;
        }

        function handleMouseDown(e) {
            if (e.button !== 0) return;
            const rect = canvas.getBoundingClientRect();
            if (e.clientX < rect.left || e.clientX > rect.right || e.clientY < rect.top || e.clientY > rect.bottom) return;

            if (isSpectating || !isAlive) { switchSpectateTarget(1); return; }
            if (!myPlayerId || !players[myPlayerId]) return;
            const now = Date.now();

            if (myClass === 'samurai') {
                // ì‚¬ë¬´ë¼ì´: ëˆ„ë¥´ëŠ” ìˆœê°„ ì°¨ì§• ì‹œì‘
                if (samuraiSlashActive || samuraiParryActive || samuraiCounterActive) return;
                const stats = CLASSES[myClass].stats;
                if (now - lastAttackTime < 1000 / stats.attackSpeed) return;
                const myPlayer = players[myPlayerId];
                const worldMouseX = mouseX + cameraX;
                const worldMouseY = mouseY + cameraY;
                const dx = worldMouseX - (myPlayer.x + PLAYER_SIZE / 2);
                const dy = worldMouseY - (myPlayer.y + PLAYER_SIZE / 2);
                samuraiChargeDir = Math.atan2(dy, dx);
                samuraiCharging = true;
                samuraiChargeStart = now;
                // Firebaseì— ì°¨ì§• ìƒíƒœ ê³µìœ 
                playersRef.child(myPlayerId).update({ samuraiCharging: true, samuraiChargeStart: now });
                // íƒ€ì´ë¨¸ ì—†ìŒ - ë§ˆìš°ìŠ¤ë¥¼ ë—„ ë•Œë§Œ ë°œì‚¬ (í’€ì°¨ì§• ìœ ì§€ ê°€ëŠ¥)
                return;
            }

            // ì‚¬ë¬´ë¼ì´ê°€ ì•„ë‹Œ ì§ì—…ì€ ê¸°ì¡´ í´ë¦­ ë¡œì§ ê·¸ëŒ€ë¡œ
            const stats = CLASSES[myClass].stats;
            // ëª¨ë˜ì‹œê³„ ì¤‘ ê³µê²© ë¶ˆê°€
            if (hourglassActive) return;
            const rageAtkSpeed = rageActive ? 1 : 0;
            const attackCooldown = 1000 / (stats.attackSpeed + rageAtkSpeed);
            if (now - lastAttackTime < attackCooldown) return;

            if (myClass === 'warrior') {
                if (warriorSwingActive) return;
                const myPlayer = players[myPlayerId];
                const worldMouseX = mouseX + cameraX;
                const worldMouseY = mouseY + cameraY;
                const dx = worldMouseX - (myPlayer.x + PLAYER_SIZE / 2);
                const dy = worldMouseY - (myPlayer.y + PLAYER_SIZE / 2);
                warriorSwingDir = Math.atan2(dy, dx);
                warriorSwingActive = true;
                warriorSwingFrames = WARRIOR_SWING_TOTAL;
                swingHitIds.clear();
                if (warriorSpinReady) {
                    warriorSpinReady = false;
                    _currentSwingArc = WARRIOR_SPIN_ARC;
                    _currentSwingRange = WARRIOR_SPIN_RANGE;
                } else {
                    _currentSwingArc = WARRIOR_SWING_ARC;
                    _currentSwingRange = WARRIOR_SWING_RANGE;
                }
                const swingData = {
                    ownerId: myPlayerId,
                    dir: warriorSwingDir,
                    arc: _currentSwingArc,
                    range: _currentSwingRange,
                    totalFrames: WARRIOR_SWING_TOTAL,
                    createdAt: Date.now(),
                    ox: myPlayer.x + PLAYER_SIZE / 2,
                    oy: myPlayer.y + PLAYER_SIZE / 2
                };
                swingsRef.child(myPlayerId).set(swingData);
                playerSwings[myPlayerId] = { ...swingData, frames: WARRIOR_SWING_TOTAL, angle: warriorSwingDir - _currentSwingArc / 2 };
                lastAttackTime = now;
            } else if (myClass === 'assassin') {
                if (assassinStealthActive) {
                    assassinStealthActive = false;
                    playersRef.child(myPlayerId).update({ stealthed: false });
                }
                if (assassinStabActive) return;
                const myPlayer = players[myPlayerId];
                const worldMouseX = mouseX + cameraX;
                const worldMouseY = mouseY + cameraY;
                const dx = worldMouseX - (myPlayer.x + PLAYER_SIZE / 2);
                const dy = worldMouseY - (myPlayer.y + PLAYER_SIZE / 2);
                assassinStabDir = Math.atan2(dy, dx);
                assassinStabActive = true;
                assassinStabFrames = ASSASSIN_STAB_TOTAL;
                assassinStabHit = false;
                const stabData = {
                    ownerId: myPlayerId,
                    x: myPlayer.x + PLAYER_SIZE / 2,
                    y: myPlayer.y + PLAYER_SIZE / 2,
                    dir: assassinStabDir,
                    totalFrames: ASSASSIN_STAB_TOTAL,
                    createdAt: now
                };
                stabsRef.child(myPlayerId).set(stabData);
                playerStabs[myPlayerId] = { ...stabData, frames: ASSASSIN_STAB_TOTAL };
                lastAttackTime = now;
            } else if (myClass === 'blacksmith') {
                if (smithForging || smithHammerActive) return;
                const myPlayer = players[myPlayerId];
                const worldMouseX = mouseX + cameraX;
                const worldMouseY = mouseY + cameraY;
                const dx = worldMouseX - (myPlayer.x + PLAYER_SIZE / 2);
                const dy = worldMouseY - (myPlayer.y + PLAYER_SIZE / 2);
                smithHammerDir = Math.atan2(dy, dx);
                smithHammerActive = true;
                smithHammerFrames = SMITH_HAMMER_TOTAL;
                smithHammerHit = false;
                smithHammerHitIds.clear();
                const hammerData = {
                    ownerId: myPlayerId,
                    x: myPlayer.x + PLAYER_SIZE / 2,
                    y: myPlayer.y + PLAYER_SIZE / 2,
                    dir: smithHammerDir,
                    totalFrames: SMITH_HAMMER_TOTAL,
                    createdAt: now,
                    enhanceLevel: smithEnhanceLevel
                };
                smithHammersRef.child(myPlayerId).set(hammerData);
                playerHammers[myPlayerId] = { ...hammerData, frames: SMITH_HAMMER_TOTAL };
                lastAttackTime = now;
            } else if (myClass === 'jumong') {
                // ì£¼ëª½: ë§µ ëê¹Œì§€ ë‚ ì•„ê°€ëŠ” í™”ì‚´
                const myPlayer = players[myPlayerId];
                const worldMouseX = mouseX + cameraX;
                const worldMouseY = mouseY + cameraY;
                const dx = worldMouseX - (myPlayer.x + PLAYER_SIZE / 2);
                const dy = worldMouseY - (myPlayer.y + PLAYER_SIZE / 2);
                const dist = Math.sqrt(dx*dx + dy*dy) || 1;
                const dirX = dx / dist, dirY = dy / dist;
                const sx = myPlayer.x + PLAYER_SIZE / 2;
                const sy = myPlayer.y + PLAYER_SIZE / 2;
                const arrowData = {
                    id: myPlayerId + '_arrow_' + now,
                    ownerId: myPlayerId,
                    x: sx, y: sy,
                    vx: dirX * JUMONG_ARROW_SPEED,
                    vy: dirY * JUMONG_ARROW_SPEED,
                    damage: CLASSES.jumong.stats.attack,
                    dir: Math.atan2(dirY, dirX),
                    createdAt: now,
                    maxLifetime: (JUMONG_ARROW_RANGE / JUMONG_ARROW_SPEED) * (1000/60)
                };
                // ë¡œì»¬ bulletìœ¼ë¡œë„ ë“±ë¡ (ì¶©ëŒ íŒì •ìš©)
                const bulletData = {
                    id: arrowData.id,
                    x: sx, y: sy,
                    vx: arrowData.vx, vy: arrowData.vy,
                    damage: arrowData.damage,
                    ownerId: myPlayerId,
                    createdAt: now,
                    maxLifetime: arrowData.maxLifetime,
                    isSkillBullet: false,
                    isArrow: true
                };
                bulletIds.add(bulletData.id);
                bullets.push(bulletData);
                bulletsRef.child(bulletData.id).set(bulletData);
                // í™”ì‚´ ì‹œê° ì´í™íŠ¸ Firebase ê³µìœ 
                jumongArrowsRef.child(arrowData.id).set(arrowData);
                playerJumongArrows[arrowData.id] = { ...arrowData, life: 1.0 };
                setTimeout(() => {
                    jumongArrowsRef.child(arrowData.id).remove();
                    delete playerJumongArrows[arrowData.id];
                }, arrowData.maxLifetime + 200);
                lastAttackTime = now;
            } else if (myClass === 'muhui') {
                // ë¬´í¬: ë¶€ì±„ê¼´ 5ë°œ ë²šê½ƒë¹„ìˆ˜
                const myPlayer = players[myPlayerId];
                const worldMouseX = mouseX + cameraX;
                const worldMouseY = mouseY + cameraY;
                const dx = worldMouseX - (myPlayer.x + PLAYER_SIZE / 2);
                const dy = worldMouseY - (myPlayer.y + PLAYER_SIZE / 2);
                const baseAngle = Math.atan2(dy, dx);
                const sx = myPlayer.x + PLAYER_SIZE / 2;
                const sy = myPlayer.y + PLAYER_SIZE / 2;
                for (let i = 0; i < MUHUI_PETAL_COUNT; i++) {
                    const spread = (Math.random() - 0.5) * MUHUI_PETAL_SPREAD;
                    const angle = baseAngle + spread;
                    const pid = myPlayerId + '_petal_' + now + '_' + i;
                    const bData = {
                        id: pid, x: sx, y: sy,
                        vx: Math.cos(angle) * MUHUI_PETAL_SPEED,
                        vy: Math.sin(angle) * MUHUI_PETAL_SPEED,
                        damage: CLASSES.muhui.stats.attack,
                        ownerId: myPlayerId,
                        createdAt: now,
                        maxLifetime: (MUHUI_PETAL_RANGE / MUHUI_PETAL_SPEED) * (1000/60),
                        isSkillBullet: false,
                        isPetal: true,
                        angle: angle
                    };
                    bulletIds.add(pid);
                    bullets.push(bData);
                    bulletsRef.child(pid).set(bData);
                }
                lastAttackTime = now;
            } else {
                // ë³´ë³‘ ì´ì ì‚¬: ì²« ë°œ ì¦‰ì‹œ, ë‘ ë²ˆì§¸ ë°œ 80ms í›„
                shootBullet(mouseX, mouseY);
                setTimeout(() => {
                    if (myPlayerId && players[myPlayerId]) shootBullet(mouseX, mouseY);
                }, 80);
                lastAttackTime = now;
            }
        }

        function handleMouseUp(e) {
            if (e.button !== 0) return;
            if (myClass === 'samurai' && samuraiCharging) {
                fireSamuraiThrust();
            }
        }
        // ìº”ë²„ìŠ¤ ë°–ì—ì„œ ë§ˆìš°ìŠ¤ë¥¼ ë–¼ë„ ì°¨ì§• ë°œì‚¬/ì·¨ì†Œ ì²˜ë¦¬
        window.addEventListener('mouseup', (e) => {
            if (e.button !== 0) return;
            if (myClass === 'samurai' && samuraiCharging) {
                fireSamuraiThrust();
            }
        });

        function handleRightClick(e) {
            e.preventDefault();
            // ìº”ë²„ìŠ¤ ë²”ìœ„ ë°– í´ë¦­ ë¬´ì‹œ
            const rect = canvas.getBoundingClientRect();
            if (e.clientX < rect.left || e.clientX > rect.right || e.clientY < rect.top || e.clientY > rect.bottom) return;

            if (isSpectating || !isAlive) { switchSpectateTarget(-1); return; }
            if (!myPlayerId || !players[myPlayerId]) return;
            if (isUsingSkill) return;
            const now = Date.now();
            if (now < skillCooldownEnd) return;

            if (myClass === 'warrior') {
                // ì›Œë¦¬ì–´ ìŠ¤í‚¬: 3ì´ˆ ë°©ì–´ + ì´ë™ì†ë„ +1.5 + íšŒì „ë² ê¸° ì¤€ë¹„ (íˆíŠ¸ ì‹œ ìë™ ë¦¬ì…‹)
                warriorSkillActive = true;
                warriorSkillEnd = now + 3000;
                warriorSpinReady = true;
                skillCooldownEnd = now + CLASSES.warrior.skill.cooldown * 1000;
                // Firebaseì— ìŠ¤í‚¬ ìƒíƒœ ê³µìœ 
                playersRef.child(myPlayerId).update({ warriorSkillActive: true });
            } else if (myClass === 'assassin') {
                // ì–´ìŒ”ì‹  ìŠ¤í‚¬: ì—°ê¸°ì™€ í•¨ê»˜ ì€ì‹  ëŒì…
                assassinStealthActive = true;
                assassinStealthEnd = now + 3000; // ìµœëŒ€ 3ì´ˆ ì€ì‹ 
                skillCooldownEnd = now + CLASSES.assassin.skill.cooldown * 1000;
                // Firebaseì— ì€ì‹  ìƒíƒœ ê³µìœ 
                playersRef.child(myPlayerId).update({ stealthed: true });
                // ì—°ê¸° ì´í™íŠ¸ ë¡œì»¬ ìƒì„± + Firebase ê³µìœ 
                const myPlayer = players[myPlayerId];
                spawnSmokeEffect(myPlayer.x, myPlayer.y);
                const smokeData = {
                    ownerId: myPlayerId,
                    x: myPlayer.x,
                    y: myPlayer.y,
                    createdAt: now
                };
                smokesRef.child(myPlayerId).set(smokeData);
                setTimeout(() => smokesRef.child(myPlayerId).remove(), 3000);
            } else if (myClass === 'samurai') {
                // ì‚¬ë¬´ë¼ì´ íŒ¨ë§: 1ì´ˆ ê²½ì§ + ê³µê²© ë¬´íš¨í™”, ë§ìœ¼ë©´ ë°˜ê²© ëŒì§„
                if (samuraiParryActive || samuraiCounterActive || samuraiSlashActive) return;
                cancelSamuraiCharge(); // ì°¨ì§• ì¤‘ì´ë©´ ì·¨ì†Œ
                samuraiParryActive = true;
                samuraiParryHit = false;
                samuraiParryEnd = now + 1000;
                skillCooldownEnd = now + CLASSES.samurai.skill.cooldown * 1000;
                // íŒ¨ë§ ë°©í–¥ = íŒ¨ë§ ì‚¬ìš© ìˆœê°„ì˜ ë§ˆìš°ìŠ¤ ë°©í–¥ìœ¼ë¡œ í™•ì • ê³ ì •
                const myPlayer = players[myPlayerId];
                const worldMouseX = mouseX + cameraX;
                const worldMouseY = mouseY + cameraY;
                const pdx = worldMouseX - (myPlayer.x + PLAYER_SIZE / 2);
                const pdy = worldMouseY - (myPlayer.y + PLAYER_SIZE / 2);
                const pDist = Math.sqrt(pdx * pdx + pdy * pdy);
                samuraiParryDir = pDist > 10 ? Math.atan2(pdy, pdx) : 0;
                // Firebaseì— íŒ¨ë§ ìƒíƒœ ê³µìœ 
                playersRef.child(myPlayerId).update({ samuraiParrying: true });
                samuraiSlashesRef.child('parry_' + myPlayerId).set({
                    ownerId: myPlayerId, type: 'parry', createdAt: now
                });
                // 1ì´ˆ í›„ íŒ¨ë§ ì¢…ë£Œ
                setTimeout(() => {
                    if (!samuraiParryActive) return;
                    samuraiParryActive = false;
                    playersRef.child(myPlayerId).update({ samuraiParrying: false });
                    samuraiSlashesRef.child('parry_' + myPlayerId).remove();
                    if (samuraiParryHit) {
                        _startSamuraiCounter();
                    }
                }, 1000);
            } else if (myClass === 'blacksmith') {
                // ëŒ€ì¥ì¥ì´ ìŠ¤í‚¬: ê°•í™” - 2ì´ˆ ê²½ì§ í›„ ëŠ¥ë ¥ì¹˜ ìƒìŠ¹
                if (smithForging || smithHammerActive) return;
                smithForging = true;
                smithForgeEnd = now + 2000;
                skillCooldownEnd = now + CLASSES.blacksmith.skill.cooldown * 1000;
                // Firebaseì— ê°•í™” ìƒíƒœ ê³µìœ  (ê²½ì§ ì¤‘ í‘œì‹œ)
                playersRef.child(myPlayerId).update({ smithForging: true });
                // ëª¨ë£¨ ë‘ë“œë¦¬ëŠ” ì´í™íŠ¸ ê³µìœ 
                const myPlayer = players[myPlayerId];
                const forgeData = {
                    ownerId: myPlayerId,
                    x: myPlayer.x + PLAYER_SIZE / 2,
                    y: myPlayer.y + PLAYER_SIZE / 2,
                    createdAt: now
                };
                smokesRef.child('forge_' + myPlayerId).set(forgeData);
                setTimeout(() => smokesRef.child('forge_' + myPlayerId).remove(), 2000);
                // 1.5ì´ˆ í›„ ê²½ì§ í•´ì œ + ëŠ¥ë ¥ì¹˜ ìƒìŠ¹
                setTimeout(() => {
                    smithForging = false;
                    smithEnhanceLevel++;
                    // í˜„ì¬ ëŠ¥ë ¥ì¹˜ì— ê°•í™” ì ìš© (ë§¤ ê°•í™”ë§ˆë‹¤ +0.25/+5/+0.25 ê³ ì • ì¦ê°€)
                    const cur = CLASSES.blacksmith.stats;
                    const newMoveSpeed = cur.moveSpeed + 0.25;
                    const newAttack = cur.attack + 5;
                    const newAttackSpeed = cur.attackSpeed + 0.25;
                    // ì²´ë ¥ì€ ìµœëŒ€ì²´ë ¥ +10 ì¦ê°€, í˜„ì¬ì²´ë ¥ë„ +10
                    const curHp = players[myPlayerId] ? players[myPlayerId].health : cur.health;
                    const newMaxHp = cur.health + 10;
                    const newHp = Math.min(curHp + 10, newMaxHp);
                    // CLASSES ìŠ¤íƒ¯ ë¡œì»¬ ì—…ë°ì´íŠ¸ (ê³µê²© ê³„ì‚°ì— ì‚¬ìš©)
                    CLASSES.blacksmith.stats = {
                        moveSpeed: newMoveSpeed,
                        attack: newAttack,
                        attackSpeed: newAttackSpeed,
                        health: newMaxHp
                    };
                    playersRef.child(myPlayerId).update({
                        smithForging: false,
                        smithEnhanceLevel: smithEnhanceLevel,
                        health: newHp,
                        maxHealth: newMaxHp
                    });
                    // ê°•í™” íŒŒí‹°í´ ì´í™íŠ¸ (ë¡œì»¬ + Firebase)
                    if (players[myPlayerId]) {
                        spawnForgeEnhanceEffect(players[myPlayerId].x, players[myPlayerId].y);
                    }
                }, 2000);
            } else if (myClass === 'jumong') {
                // ì£¼ëª½ ìŠ¤í‚¬: í˜¸í¬ì•„ì´ â€” ì‹œì•¼ 2.5ë°° í™•ëŒ€
                jumongHawkeyeActive = true;
                jumongHawkeyeEnd = now + JUMONG_HAWKEYE_DURATION;
                jumongTargetZoom = JUMONG_HAWKEYE_ZOOM;
                skillCooldownEnd = now + CLASSES.jumong.skill.cooldown * 1000;
                playersRef.child(myPlayerId).update({ jumongHawkeye: true });
                setTimeout(() => {
                    jumongHawkeyeActive = false;
                    jumongTargetZoom = 1.0;
                    playersRef.child(myPlayerId).update({ jumongHawkeye: false });
                }, JUMONG_HAWKEYE_DURATION);
            } else if (myClass === 'muhui') {
                // ë¬´í¬ ìŠ¤í‚¬: ê½ƒë³´ë¼ ì¶¤ â€” ì¥íŒ ì„¤ì¹˜
                if (muhuiZoneActive) return;
                muhuiZoneActive = true;
                muhuiZoneEnd = now + MUHUI_ZONE_DURATION;
                muhuiZoneDmgTimer = 0;
                skillCooldownEnd = now + CLASSES.muhui.skill.cooldown * 1000;
                const myPlayer = players[myPlayerId];
                const zoneData = {
                    id: myPlayerId + '_zone_' + now,
                    ownerId: myPlayerId,
                    x: myPlayer.x + PLAYER_SIZE / 2,
                    y: myPlayer.y + PLAYER_SIZE / 2,
                    radius: MUHUI_ZONE_RADIUS,
                    createdAt: now,
                    duration: MUHUI_ZONE_DURATION
                };
                muhuiZonesRef.child(myPlayerId).set(zoneData);
                playerMuhuiZones[myPlayerId] = { ...zoneData };
                playersRef.child(myPlayerId).update({ muhuiZone: true });
                setTimeout(() => {
                    muhuiZoneActive = false;
                    muhuiZonesRef.child(myPlayerId).remove();
                    delete playerMuhuiZones[myPlayerId];
                    playersRef.child(myPlayerId).update({ muhuiZone: false });
                }, MUHUI_ZONE_DURATION);
            } else {
                useSkill(mouseX, mouseY);
            }
        }

        // ========== ê´€ì „ ëŒ€ìƒ ë°©í–¥ ì „í™˜ (+1: ë‹¤ìŒ, -1: ì´ì „) ==========
        function switchSpectateTarget(direction) {
            const alivePlayers = Object.keys(players).filter(id =>
                id !== myPlayerId && id !== DUMMY_ID && !players[id].isSpectator && players[id].health > 0
            );
            if (alivePlayers.length === 0) { spectateTargetId = null; return; }

            const currentIdx = alivePlayers.indexOf(spectateTargetId);
            let nextIdx = (currentIdx + direction + alivePlayers.length) % alivePlayers.length;
            spectateTargetId = alivePlayers[nextIdx];
        }

        // ========== ì¿¨íƒ€ì„ HUD ì—…ë°ì´íŠ¸ ==========
        function updateCooldownHUD() {
            const now = Date.now();

            // ìŠ¤í  ì¿¨íƒ€ì„
            const spell = SPELLS[mySpell];
            const spellTotal = spell ? spell.cooldown * 1000 : 3000;
            const spellRemaining = Math.max(0, spellCooldownEnd - now);
            const spellPct = spellRemaining === 0 ? 100 : Math.round((1 - spellRemaining / spellTotal) * 100);
            const spellHudBar  = document.getElementById('spellHudCoolBar');
            const spellHudText = document.getElementById('spellHudCoolText');
            const spellHudName = document.getElementById('spellHudName');
            const spellActionLbl = document.getElementById('spellActionLabel');
            if (spell) {
                if (spellHudName) spellHudName.textContent = spell.icon + ' ' + spell.name;
                if (spellActionLbl) spellActionLbl.textContent = spell.name;
            }
            if (spellHudBar && spellHudText) {
                spellHudBar.style.width = spellPct + '%';
                spellHudText.textContent = spellRemaining === 0 ? 'ì¤€ë¹„' : (spellRemaining / 1000).toFixed(1) + 's';
                spellHudText.style.color = spellRemaining === 0 ? '#ffaa00' : '#aaa';
                spellHudBar.style.background = spell ? spell.color : '#ffaa00';
            }

            // ìŠ¤í‚¬ ì¿¨íƒ€ì„ + ìŠ¤í‚¬ëª… ë™ì  í‘œì‹œ
            const classData = CLASSES[myClass];
            const skillName = classData ? classData.skill.name : 'ìŠ¤í‚¬';
            const skillTotal = classData ? classData.skill.cooldown * 1000 : 20000;
            const skillRemaining = Math.max(0, skillCooldownEnd - now);
            const skillPct = skillRemaining === 0 ? 100 : Math.round((1 - skillRemaining / skillTotal) * 100);
            const skillBar = document.getElementById('skillCoolBar');
            const skillText = document.getElementById('skillCoolText');
            const skillNameLabel = document.getElementById('skillNameLabel');
            const skillActionLabel = document.getElementById('skillActionLabel');
            if (skillNameLabel) skillNameLabel.textContent = skillName;
            if (skillActionLabel) skillActionLabel.textContent = skillName;
            if (skillBar && skillText) {
                skillBar.style.width = skillPct + '%';
                skillText.textContent = skillRemaining === 0 ? 'ì¤€ë¹„' : (skillRemaining / 1000).toFixed(1) + 's';
                skillText.style.color = skillRemaining === 0 ? '#00ff88' : '#aaa';
                skillBar.style.background = skillRemaining === 0 ? '#00ff88' : '#ff4444';
            }
        }

        // ========== ìŠ¤í  ì‹œìŠ¤í…œ ==========
        function performSpell() {
            if (!myPlayerId || !players[myPlayerId]) return;
            const now = Date.now();
            const spell = SPELLS[mySpell];
            if (!spell) return;
            if (now < spellCooldownEnd) return;

            spellCooldownEnd = now + spell.cooldown * 1000;

            if (mySpell === 'dash') {
                _castDash();
            } else if (mySpell === 'heal') {
                _castHeal(now);
            } else if (mySpell === 'rage') {
                _castRage(now);
            } else if (mySpell === 'fluid') {
                _castFluid(now);
            } else if (mySpell === 'hourglass') {
                _castHourglass(now);
            }

            // Firebaseì— ìŠ¤í  ì´í™íŠ¸ ê³µìœ 
            const myPlayer = players[myPlayerId];
            const effectData = {
                id: myPlayerId + '_spell_' + now,
                ownerId: myPlayerId,
                spell: mySpell,
                x: myPlayer ? myPlayer.x + PLAYER_SIZE/2 : 0,
                y: myPlayer ? myPlayer.y + PLAYER_SIZE/2 : 0,
                createdAt: now,
                color: spell.color
            };
            spellEffectsRef.child(myPlayerId).set(effectData);
            setTimeout(() => spellEffectsRef.child(myPlayerId).remove(), 4000);

            // ë¡œì»¬ì—ë„ ì´í™íŠ¸ ë“±ë¡
            playerSpellEffects[myPlayerId] = { ...effectData, localStartedAt: now };
        }

        // â”€â”€ ëŒ€ì‰¬ ìºìŠ¤íŒ… â”€â”€
        function _castDash() {
            if (isDashing) return;
            const myPlayer = players[myPlayerId];
            const worldMouseX = mouseX + cameraX;
            const worldMouseY = mouseY + cameraY;
            const dx = worldMouseX - (myPlayer.x + PLAYER_SIZE / 2);
            const dy = worldMouseY - (myPlayer.y + PLAYER_SIZE / 2);
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist === 0) return;
            // ì–´ìŒ”ì‹  ì€ì‹  ì¤‘ ëŒ€ì‰¬ ì‹œ ì€ì‹  í•´ì œ
            if (myClass === 'assassin' && assassinStealthActive) {
                assassinStealthActive = false;
                playersRef.child(myPlayerId).update({ stealthed: false });
            }
            const baseSpeed = CLASSES[myClass].stats.moveSpeed;
            const effectiveSpeed = (myClass === 'assassin' && assassinStealthActive)
                ? baseSpeed * 2 : baseSpeed;
            const DASH_SPEED = effectiveSpeed * 5.6;
            dashVx = (dx / dist) * DASH_SPEED;
            dashVy = (dy / dist) * DASH_SPEED;
            dashRemainFrames = DASH_TOTAL_FRAMES;
            isDashing = true;
        }

        // â”€â”€ ì¬ìƒ ìºìŠ¤íŒ… â”€â”€
        function _castHeal(now) {
            healActive = true;
            healTicks = 0;
            healTimer = now;
        }

        // â”€â”€ ë¶„ë…¸ ìºìŠ¤íŒ… â”€â”€
        function _castRage(now) {
            rageActive = true;
            rageEnd = now + 4000;
            playersRef.child(myPlayerId).update({ rageActive: true });
        }

        // â”€â”€ ìœ ì²´í™” ìºìŠ¤íŒ… â”€â”€
        function _castFluid(now) {
            fluidActive = true;
            fluidPhase = 'ramp';
            fluidEnd = now + 4000; // ì´ 4ì´ˆ (1+2+1)
            fluidBonus = 0;
            playersRef.child(myPlayerId).update({ fluidActive: true });
        }

        // â”€â”€ ëª¨ë˜ì‹œê³„ ìºìŠ¤íŒ… â”€â”€ (ë¡œì»¬ë§Œ ì²˜ë¦¬ â€” Firebase ì „íŒŒ ì‹œ ë‹¤ë¥¸ í´ë¼ì´ì–¸íŠ¸ ì˜í–¥ ì—†ê²Œ)
        function _castHourglass(now) {
            hourglassActive = true;
            hourglassEnd = now + 3000;
            // hourglassActiveëŠ” ë¡œì»¬ ìƒíƒœë§Œ ì‚¬ìš©. Firebaseì— ì˜¬ë¦¬ì§€ ì•ŠìŒ.
        }

        // ========== ìŠ¤í  ì—…ë°ì´íŠ¸ (ê²Œì„ ë£¨í”„ì—ì„œ ë§¤ í”„ë ˆì„ í˜¸ì¶œ) ==========
        function updateSpells() {
            if (!myPlayerId || !players[myPlayerId] || !isAlive) return;
            const now = Date.now();
            const myPlayer = players[myPlayerId];

            // â”€â”€ ì¬ìƒ â”€â”€
            if (healActive && healTicks < 3) {
                if (now - healTimer >= 1000) {
                    healTimer = now;
                    healTicks++;
                    const maxHp = myPlayer.maxHealth || CLASSES[myClass].stats.health;
                    const newHp = Math.min(maxHp, myPlayer.health + 5);
                    myPlayer.health = newHp;
                    playersRef.child(myPlayerId).update({ health: newHp });
                    // ì´ˆë¡ í íŒŒí‹°í´
                    _spawnSpellParticles(myPlayer.x + PLAYER_SIZE/2, myPlayer.y + PLAYER_SIZE/2, '#00ff88', 8);
                    if (healTicks >= 3) healActive = false;
                }
            }

            // â”€â”€ ë¶„ë…¸ â”€â”€
            if (rageActive && now > rageEnd) {
                rageActive = false;
                playersRef.child(myPlayerId).update({ rageActive: false });
            }

            // â”€â”€ ìœ ì²´í™” â”€â”€
            if (fluidActive) {
                const elapsed = now - (fluidEnd - 4000);
                if (elapsed < 1000) {
                    fluidPhase = 'ramp';
                    fluidBonus = 1.5 * (elapsed / 1000);
                } else if (elapsed < 3000) {
                    fluidPhase = 'hold';
                    fluidBonus = 1.5;
                } else if (elapsed < 4000) {
                    fluidPhase = 'decay';
                    fluidBonus = 1.5 * (1 - (elapsed - 3000) / 1000);
                } else {
                    fluidActive = false;
                    fluidBonus = 0;
                    playersRef.child(myPlayerId).update({ fluidActive: false });
                }
            }

            // â”€â”€ ëª¨ë˜ì‹œê³„ â”€â”€ (ë¡œì»¬ë§Œ ì²˜ë¦¬)
            if (hourglassActive && now > hourglassEnd) {
                hourglassActive = false;
                // Firebase ì—…ë°ì´íŠ¸ ì—†ìŒ â€” ë¡œì»¬ ìƒíƒœë§Œ í•´ì œ
            }
        }

        // â”€â”€ ìŠ¤í  íŒŒí‹°í´ (ë¡œì»¬+Firebase) â”€â”€
        function _spawnSpellParticles(cx, cy, color, count) {
            const now = Date.now();
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 2.5 + 0.5;
                const p = {
                    id: myPlayerId + '_sp_' + now + '_' + i,
                    ownerId: myPlayerId,
                    x: cx + (Math.random()-0.5)*10,
                    y: cy + (Math.random()-0.5)*10,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 1,
                    radius: Math.random() * 5 + 2,
                    life: 1.0,
                    decay: 0.04 + Math.random() * 0.03,
                    createdAt: now,
                    color
                };
                particleIds.add(p.id);
                particles.push(p);
                if (i % 2 === 0) { // ê²©ì¸ë±ìŠ¤ë§Œ Firebase ì—…ë¡œë“œ
                    particlesRef.child(p.id).set(p);
                    setTimeout(() => { try { particlesRef.child(p.id).remove(); } catch(e){} }, 1500);
                }
            }
        }

        // ========== ëŒ€ì‰¬ ì‹œìŠ¤í…œ (ëŒì§„) ==========
        function performDash() {
            if (!myPlayerId || !players[myPlayerId]) return;
            if (isDashing) return;
            const now = Date.now();
            if (now < dashCooldownEnd) return;

            const myPlayer = players[myPlayerId];
            const worldMouseX = mouseX + cameraX;
            const worldMouseY = mouseY + cameraY;
            const dx = worldMouseX - (myPlayer.x + PLAYER_SIZE / 2);
            const dy = worldMouseY - (myPlayer.y + PLAYER_SIZE / 2);
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist === 0) return;

            // ëŒ€ì‰¬ ì†ë„ = ì´ë™ì†ë„ * 5.6 (ê¸°ì¤€ moveSpeed 5 â†’ speed 28)
            // ì–´ìŒ”ì‹  ì€ì‹  ì¤‘ ëŒ€ì‰¬ ì‹œ ì€ì‹  ì´ë™ì†ë„(2ë°°) ì ìš©
            const baseSpeed = CLASSES[myClass].stats.moveSpeed;
            const effectiveSpeed = (myClass === 'assassin' && assassinStealthActive)
                ? baseSpeed * 2
                : baseSpeed;
            const DASH_SPEED = effectiveSpeed * 5.6;

            // ëŒì§„ ë°©í–¥ ì €ì¥
            dashVx = (dx / dist) * DASH_SPEED;
            dashVy = (dy / dist) * DASH_SPEED;
            dashRemainFrames = DASH_TOTAL_FRAMES;
            isDashing = true;
            dashCooldownEnd = now + DASH_COOLDOWN * 1000;
        }

        // ========== ì–´ìŒ”ì‹  ì—°ê¸° ì´í™íŠ¸ ==========
        function spawnSmokeEffect(x, y) {
            const cx = x + PLAYER_SIZE / 2;
            const cy = y + PLAYER_SIZE / 2;
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 2 + 0.5;
                const size = Math.random() * 10 + 5;
                assassinSmokeParticles.push({
                    x: cx + (Math.random() - 0.5) * 20,
                    y: cy + (Math.random() - 0.5) * 20,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 0.5,
                    radius: size,
                    life: 1.0,
                    decay: 0.025 + Math.random() * 0.02
                });
            }
        }

        // ========== ì–´ìŒ”ì‹  ì°Œë¥´ê¸° ì—…ë°ì´íŠ¸ ==========
        function updateAssassinStab() {
            // â”€â”€ ë‚´ ì°Œë¥´ê¸° (ì¶©ëŒ íŒì • + ì§„í–‰) â”€â”€
            if (assassinStabActive && myClass === 'assassin' && myPlayerId && players[myPlayerId]) {
                const myPlayer = players[myPlayerId];
                const cx = myPlayer.x + PLAYER_SIZE / 2;
                const cy = myPlayer.y + PLAYER_SIZE / 2;
                const progress = 1 - assassinStabFrames / ASSASSIN_STAB_TOTAL;

                // ì°Œë¥´ê¸° ëë¶€ë¶„ ìœ„ì¹˜
                const tipX = cx + Math.cos(assassinStabDir) * ASSASSIN_STAB_RANGE * Math.min(1, progress * 2);
                const tipY = cy + Math.sin(assassinStabDir) * ASSASSIN_STAB_RANGE * Math.min(1, progress * 2);

                // playerStabsì—ë„ ë‚´ í˜„ì¬ ìƒíƒœ ë°˜ì˜ (ë Œë”ë§ì— ì‚¬ìš©)
                // x/yëŠ” ê³µê²© ì‹œì‘ ìœ„ì¹˜ ê³ ì • (ë§¤ í”„ë ˆì„ ë®ì–´ì“°ë©´ ì´ë™ ì‹œ ê¶¤ì  ì–´ê¸‹ë‚¨)
                playerStabs[myPlayerId] = {
                    ownerId: myPlayerId,
                    x: playerStabs[myPlayerId]?.x ?? cx,
                    y: playerStabs[myPlayerId]?.y ?? cy,
                    dir: assassinStabDir,
                    totalFrames: ASSASSIN_STAB_TOTAL,
                    frames: assassinStabFrames,
                    createdAt: playerStabs[myPlayerId]?.createdAt || Date.now()
                };

                if (!assassinStabHit) {
                    for (let id in players) {
                        if (id === myPlayerId) continue;
                        const t = players[id];
                        if (t.isSpectator || t.health <= 0) continue;
                        const tx = t.x + PLAYER_SIZE / 2;
                        const ty = t.y + PLAYER_SIZE / 2;
                        // ì°Œë¥´ê¸° ì„ ë¶„ê³¼ íƒ€ê²Ÿ ì‚¬ì´ ìµœë‹¨ê±°ë¦¬ë¡œ íˆíŠ¸íŒì • (ë„“ì´ ì¦ê°€)
                        const stabEndX = cx + Math.cos(assassinStabDir) * ASSASSIN_STAB_RANGE;
                        const stabEndY = cy + Math.sin(assassinStabDir) * ASSASSIN_STAB_RANGE;
                        const ldx = stabEndX - cx;
                        const ldy = stabEndY - cy;
                        const lenSq = ldx * ldx + ldy * ldy;
                        const t2 = Math.max(0, Math.min(1, ((tx - cx) * ldx + (ty - cy) * ldy) / lenSq));
                        const nearX = cx + t2 * ldx;
                        const nearY = cy + t2 * ldy;
                        const dist = Math.sqrt((nearX - tx) ** 2 + (nearY - ty) ** 2);
                        const HIT_WIDTH = PLAYER_SIZE / 2 + 14;
                        if (dist < HIT_WIDTH) {
                            assassinStabHit = true;
                            dealDamage(id, CLASSES.assassin.stats.attack, tx, ty);
                            break;
                        }
                    }
                }

                assassinStabFrames--;
                if (assassinStabFrames <= 0) {
                    assassinStabActive = false;
                    delete playerStabs[myPlayerId];
                    stabsRef.child(myPlayerId).remove();
                }
            }

            // â”€â”€ ë‹¤ë¥¸ í”Œë ˆì´ì–´ ì°Œë¥´ê¸° ì• ë‹ˆë©”ì´ì…˜ ì§„í–‰ â”€â”€
            for (const id in playerStabs) {
                if (id === myPlayerId) continue;
                const stab = playerStabs[id];
                stab.frames--;
                if (stab.frames <= 0) delete playerStabs[id];
            }
        }

        // ========== ì–´ìŒ”ì‹  ì—°ê¸° íŒŒí‹°í´ ì—…ë°ì´íŠ¸ ==========
        function updateSmokeParticles() {
            for (let i = assassinSmokeParticles.length - 1; i >= 0; i--) {
                const p = assassinSmokeParticles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.95;
                p.vy *= 0.95;
                p.life -= p.decay;
                if (p.life <= 0) assassinSmokeParticles.splice(i, 1);
            }
        }

        // ëŒ€ì‰¬ íŒŒí‹°í´ ìƒì„± + Firebase ê³µìœ 
        let _dashFrameCount = 0;
        function spawnDashParticles(x, y) {
            _dashFrameCount++;
            const now = Date.now();
            // ê²©í”„ë ˆì„ë§ˆë‹¤ë§Œ Firebase ì—…ë¡œë“œ (60fps â†’ 30fps write)
            const doUpload = (_dashFrameCount % 2 === 0);
            const baseColor = players[myPlayerId] ? players[myPlayerId].color : '#fff';
            // ëŒ€ì¥ì¥ì´ ê°•í™” ë ˆë²¨ì— ë”°ë¼ í™©ê¸ˆë¹›ìœ¼ë¡œ ë³€í™”
            const color = (myClass === 'blacksmith' && smithEnhanceLevel >= 3) ? '#ffd700'
                        : (myClass === 'blacksmith' && smithEnhanceLevel >= 1) ? '#ff8c00'
                        : baseColor;
            for (let i = 0; i < 3; i++) { // 5â†’3ê°œë¡œ ê°ì†Œ
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 2 + 0.5;
                const decay = 0.09 + Math.random() * 0.05;
                const p = {
                    id: myPlayerId + '_p_' + now + '_' + i,
                    ownerId: myPlayerId,
                    x: x + PLAYER_SIZE / 2,
                    y: y + PLAYER_SIZE / 2,
                    vx: Math.cos(angle) * speed - dashVx * 0.12,
                    vy: Math.sin(angle) * speed - dashVy * 0.12,
                    radius: Math.random() * 4 + 2,
                    life: 1.0,
                    decay,
                    createdAt: now,
                    color
                };
                particleIds.add(p.id);
                particles.push(p);
                if (doUpload) {
                    particlesRef.child(p.id).set(p);
                    setTimeout(() => { try { particlesRef.child(p.id).remove(); } catch(e){} }, 1200);
                }
            }
        }

        // íŒŒí‹°í´ ì—…ë°ì´íŠ¸ (ìµœëŒ€ 200ê°œ ì œí•œ)
        function updateParticles() {
            if (particles.length > 120) particles.splice(0, particles.length - 120);
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.88;
                p.vy *= 0.88;
                p.life -= p.decay;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        // íˆíŠ¸ ì´í™íŠ¸ ìƒì„± + Firebase ê³µìœ 
        function spawnHitEffect(x, y, isFatal) {
            const now = Date.now();
            const ef = {
                id: myPlayerId + '_hit_' + now,
                ownerId: myPlayerId,
                x, y,
                isFatal,
                createdAt: now
            };
            // ë¡œì»¬ ìƒì„±
            _addHitEffect(ef);
            // Firebase ê³µìœ 
            hitEffectsRef.child(ef.id).set(ef);
            setTimeout(() => hitEffectsRef.child(ef.id).remove(), 2000); // 600â†’2000ms
        }

        function _addHitEffect(ef) {
            const count = ef.isFatal ? 18 : 10;
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * (ef.isFatal ? 6 : 4) + 1.5;
                hitEffects.push({
                    x: ef.x,
                    y: ef.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 1.0,
                    decay: ef.isFatal ? 0.055 : 0.08,
                    radius: Math.random() * (ef.isFatal ? 5 : 3) + 2,
                    color: ef.isFatal ? '#ff4444' : '#ffaa00'
                });
            }
            // í™”ë©´ í”ë“¤ë¦¼ íš¨ê³¼ (ì¹˜ëª…íƒ€ë§Œ)
            if (ef.isFatal) flashScreen('#ff000033', 200);
        }

        let screenFlashColor = null;
        let screenFlashEnd = 0;
        function flashScreen(color, duration) {
            screenFlashColor = color;
            screenFlashEnd = Date.now() + duration;
        }

        function updateHitEffects() {
            for (let i = hitEffects.length - 1; i >= 0; i--) {
                const e = hitEffects[i];
                e.x += e.vx;
                e.y += e.vy;
                e.vx *= 0.85;
                e.vy *= 0.85;
                e.life -= e.decay;
                if (e.life <= 0) hitEffects.splice(i, 1);
            }
        }

        // ========== ì´ì•Œ ë°œì‚¬ (ë¡œì»¬ + Firebase ë™ê¸°í™”) ==========
        function shootBullet(targetScreenX, targetScreenY, isSkill = false) {
            if (!myPlayerId || !players[myPlayerId]) return;
            const myPlayer = players[myPlayerId];
            const classData = CLASSES[myClass];
            const startX = myPlayer.x + PLAYER_SIZE / 2;
            const startY = myPlayer.y + PLAYER_SIZE / 2;
            const targetX = targetScreenX + cameraX;
            const targetY = targetScreenY + cameraY;
            const dx = targetX - startX;
            const dy = targetY - startY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            if (distance === 0) return;

            const speed = isSkill ? classData.skill.bulletSpeed : classData.bulletSpeed;
            const dirX = dx / distance;
            const dirY = dy / distance;
            const now = Date.now();
            const bulletData = {
                id: myPlayerId + '_' + now + '_' + Math.random().toString(36).substr(2,5),
                x: startX,
                y: startY,
                vx: dirX * speed,
                vy: dirY * speed,
                damage: classData.stats.attack,
                ownerId: myPlayerId,
                createdAt: now,
                maxLifetime: isSkill ? 4500 : 4000,
                isSkillBullet: isSkill
            };
            bulletIds.add(bulletData.id);
            bullets.push(bulletData);
            // âš¡ Firebaseì— ì¦‰ì‹œ ê³µìœ  (setPriority ì œê±° â†’ ë‹¨ìˆœ setìœ¼ë¡œ ì•ˆì •ì„± í–¥ìƒ)
            bulletsRef.child(bulletData.id).set(bulletData);
        }

        // ========== ìŠ¤í‚¬ ì‚¬ìš© (ì—°ì‚¬) ==========
        function useSkill(targetScreenX, targetScreenY) {
            if (!myPlayerId || !players[myPlayerId]) return;
            
            const myPlayer = players[myPlayerId];
            const classData = CLASSES[myClass];
            
            // ë°©í–¥ ê³„ì‚° (ì›”ë“œ ì¢Œí‘œ)
            const startX = myPlayer.x + PLAYER_SIZE / 2;
            const startY = myPlayer.y + PLAYER_SIZE / 2;
            const targetX = targetScreenX + cameraX;
            const targetY = targetScreenY + cameraY;
            
            const dx = targetX - startX;
            const dy = targetY - startY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > 0) {
                // ìŠ¤í‚¬ ë°©í–¥ ì €ì¥ (ê³ ì •)
                skillDirection.x = dx / distance;
                skillDirection.y = dy / distance;
                
                // ìŠ¤í‚¬ ìƒíƒœ ì„¤ì •
                isUsingSkill = true;
                skillBulletCount = 0;
                lastSkillBullet = Date.now();
                
            }
        }

        // ========== ìŠ¤í‚¬ ì—…ë°ì´íŠ¸ (ì—°ì‚¬ ë°œì‚¬) ==========
        function updateSkill() {
            if (!isUsingSkill) return;
            if (!myPlayerId || !players[myPlayerId]) return;
            const now = Date.now();
            const classData = CLASSES[myClass];
            const myPlayer = players[myPlayerId];

            if (now - lastSkillBullet >= classData.skill.bulletInterval) {
                const startX = myPlayer.x + PLAYER_SIZE / 2;
                const startY = myPlayer.y + PLAYER_SIZE / 2;
                const bulletData = {
                    id: myPlayerId + '_skill_' + now + '_' + skillBulletCount,
                    x: startX,
                    y: startY,
                    vx: skillDirection.x * classData.skill.bulletSpeed,
                    vy: skillDirection.y * classData.skill.bulletSpeed,
                    damage: Math.round(classData.stats.attack * 0.75),
                    ownerId: myPlayerId,
                    createdAt: now,
                    maxLifetime: 3000,
                    isSkillBullet: true
                };
                bulletIds.add(bulletData.id);
                bullets.push(bulletData);
                bulletsRef.child(bulletData.id).set(bulletData);

                skillBulletCount++;
                lastSkillBullet = now;

                if (skillBulletCount >= classData.skill.bullets) {
                    isUsingSkill = false;
                    skillCooldownEnd = now + classData.skill.cooldown * 1000;
                }
            }
        }

        // ========== ì›Œë¦¬ì–´ ê²€ íœ˜ë‘ë¥´ê¸° ì—…ë°ì´íŠ¸ ==========
        function updateWarriorSwing() {
            // â”€â”€ ë‚´ ìŠ¤ìœ™ (ì¶©ëŒ íŒì • + ì§„í–‰) â”€â”€
            if (warriorSwingActive && myClass === 'warrior' && myPlayerId && players[myPlayerId]) {
                const myPlayer = players[myPlayerId];
                const cx = myPlayer.x + PLAYER_SIZE / 2;
                const cy = myPlayer.y + PLAYER_SIZE / 2;
                const progress = 1 - warriorSwingFrames / WARRIOR_SWING_TOTAL;
                const halfArc = _currentSwingArc / 2;
                warriorSwingAngle = warriorSwingDir - halfArc + _currentSwingArc * progress;

                // playerSwingsì—ë„ ë‚´ í˜„ì¬ ìƒíƒœ ë°˜ì˜ (ë Œë”ë§ì— ì‚¬ìš©)
                playerSwings[myPlayerId] = {
                    ownerId: myPlayerId,
                    dir: warriorSwingDir,
                    arc: _currentSwingArc,
                    range: _currentSwingRange,
                    totalFrames: WARRIOR_SWING_TOTAL,
                    frames: warriorSwingFrames,
                    angle: warriorSwingAngle,
                    createdAt: playerSwings[myPlayerId]?.createdAt || Date.now(),
                    ox: playerSwings[myPlayerId]?.ox,  // ê³µê²© ì‹œì‘ ìœ„ì¹˜ ìœ ì§€
                    oy: playerSwings[myPlayerId]?.oy
                };

                const isSpinAttack = (_currentSwingArc >= Math.PI * 1.9);

                for (let id in players) {
                    if (id === myPlayerId || swingHitIds.has(id)) continue;
                    const t = players[id];
                    if (t.isSpectator || t.health <= 0) continue;

                    const tx = t.x + PLAYER_SIZE / 2;
                    const ty = t.y + PLAYER_SIZE / 2;
                    const dx = tx - cx;
                    const dy = ty - cy;
                    const distToTarget = Math.sqrt(dx * dx + dy * dy);

                    // ê±°ë¦¬ ì²´í¬: ê²€ ë²”ìœ„ + í”Œë ˆì´ì–´ ë°˜ê²½
                    if (distToTarget > _currentSwingRange + PLAYER_SIZE / 2) continue;

                    if (isSpinAttack) {
                        // â”€â”€ 360ë„ íšŒì „: ë²”ìœ„ ì•ˆì´ë©´ ë¬´ì¡°ê±´ íˆíŠ¸ (ê°ë„ ë¬´ê´€) â”€â”€
                        swingHitIds.add(id);
                        dealDamage(id, CLASSES.warrior.stats.attack, tx, ty);
                        // â˜… ë‹¤ë¦¬ìš°ìŠ¤ ê¶ ë¦¬ì…‹: íšŒì „ë² ê¸° íˆíŠ¸ ì‹œ ì „íˆ¬íƒœì„¸ 3ì´ˆ ë¦¬ì…‹ + ë‹¤ìŒ ê³µê²©ë„ íšŒì „ë² ê¸°
                        if (warriorSkillActive) {
                            warriorSkillEnd = Date.now() + 3000;
                            warriorSpinReady = true;
                        }
                    } else {
                        // â”€â”€ ì¼ë°˜ ìŠ¤ìœ™: í˜„ì¬ê¹Œì§€ íœ˜ë‘ë¥¸ í˜¸(arc) ì•ˆì— ìˆìœ¼ë©´ íˆíŠ¸ â”€â”€
                        const swingStartAngle = warriorSwingDir - halfArc;
                        const swungArc = _currentSwingArc * progress;
                        const angleToTarget = Math.atan2(dy, dx);

                        // ê°ë„ ì°¨ì´ë¥¼ [0, swungArc] ë²”ìœ„ë¡œ ì •ê·œí™”
                        let relAngle = angleToTarget - swingStartAngle;
                        relAngle = relAngle - Math.floor(relAngle / (Math.PI * 2)) * Math.PI * 2;

                        if (relAngle <= swungArc) {
                            swingHitIds.add(id);
                            dealDamage(id, CLASSES.warrior.stats.attack, tx, ty);
                        }
                    }
                }

                warriorSwingFrames--;
                if (warriorSwingFrames <= 0) {
                    warriorSwingActive = false;
                    swingHitIds.clear();
                    delete playerSwings[myPlayerId];
                    swingsRef.child(myPlayerId).remove();
                }
            }

            // â”€â”€ ë‹¤ë¥¸ í”Œë ˆì´ì–´ ìŠ¤ìœ™ ì• ë‹ˆë©”ì´ì…˜ ì§„í–‰ â”€â”€
            for (const id in playerSwings) {
                if (id === myPlayerId) continue;
                const sw = playerSwings[id];
                const progress = 1 - sw.frames / sw.totalFrames;
                sw.angle = sw.dir - sw.arc / 2 + sw.arc * progress;
                sw.frames--;
                if (sw.frames <= 0) delete playerSwings[id];
            }
        }

        // ========== ëŒ€ì¥ì¥ì´ ë§ì¹˜ ê³µê²© ì—…ë°ì´íŠ¸ ==========
        function updateSmithHammer() {
            // â”€â”€ ë‚´ ë§ì¹˜ ê³µê²© (ì¶©ëŒ íŒì • + ì§„í–‰) â”€â”€
            if (smithHammerActive && myClass === 'blacksmith' && myPlayerId && players[myPlayerId]) {
                const myPlayer = players[myPlayerId];
                const cx = myPlayer.x + PLAYER_SIZE / 2;
                const cy = myPlayer.y + PLAYER_SIZE / 2;
                const progress = 1 - smithHammerFrames / SMITH_HAMMER_TOTAL;

                // playerHammersì—ë„ ë‚´ í˜„ì¬ ìƒíƒœ ë°˜ì˜ (ë Œë”ë§ì— ì‚¬ìš©)
                playerHammers[myPlayerId] = {
                    ownerId: myPlayerId,
                    x: cx,
                    y: cy,
                    dir: smithHammerDir,
                    totalFrames: SMITH_HAMMER_TOTAL,
                    frames: smithHammerFrames,
                    enhanceLevel: smithEnhanceLevel,
                    createdAt: playerHammers[myPlayerId]?.createdAt || Date.now()
                };

                // íŒì •ì€ ì˜ˆê³  êµ¬ê°„(SMITH_HAMMER_HIT_FRAME) ì´í›„ë¶€í„°ë§Œ í™œì„±í™”
                const elapsed = SMITH_HAMMER_TOTAL - smithHammerFrames;
                if (elapsed >= SMITH_HAMMER_HIT_FRAME && !smithHammerHit) {                    const frontDist = SMITH_HAMMER_HEIGHT;
                    const cosD = Math.cos(smithHammerDir);
                    const sinD = Math.sin(smithHammerDir);
                    // ì§ê° ë²¡í„°
                    const perpX = -sinD;
                    const perpY = cosD;

                    for (let id in players) {
                        if (id === myPlayerId || smithHammerHitIds.has(id)) continue;
                        const t = players[id];
                        if (t.isSpectator || t.health <= 0) continue;
                        const tx = t.x + PLAYER_SIZE / 2;
                        const ty = t.y + PLAYER_SIZE / 2;
                        const dx = tx - cx;
                        const dy = ty - cy;
                        // ë¡œì»¬ ì¢Œí‘œë¡œ ë³€í™˜ (ì •ë°©í–¥, ì§ê°)
                        const forward = dx * cosD + dy * sinD;
                        const lateral = dx * perpX + dy * perpY;
                        // ì‚¬ê°í˜• ë²”ìœ„ ì•ˆì´ë©´ íˆíŠ¸ (ìºë¦­í„° ë°”ë¡œ ì• ì •ì‚¬ê°í˜•)
                        const offsetFront = PLAYER_SIZE / 2 + 4;
                        if (forward >= offsetFront && forward <= offsetFront + SMITH_HAMMER_RANGE * 2 + PLAYER_SIZE / 2
                            && Math.abs(lateral) <= SMITH_HAMMER_RANGE + PLAYER_SIZE / 2) {
                            smithHammerHitIds.add(id);
                            dealDamage(id, CLASSES.blacksmith.stats.attack, tx, ty);
                        }
                    }
                    if (smithHammerHitIds.size > 0) smithHammerHit = true;
                }

                smithHammerFrames--;
                if (smithHammerFrames <= 0) {
                    smithHammerActive = false;
                    smithHammerHitIds.clear();
                    delete playerHammers[myPlayerId];
                    smithHammersRef.child(myPlayerId).remove();
                }
            }

            // â”€â”€ ë‹¤ë¥¸ í”Œë ˆì´ì–´ ë§ì¹˜ ì• ë‹ˆë©”ì´ì…˜ ì§„í–‰ â”€â”€
            for (const id in playerHammers) {
                if (id === myPlayerId) continue;
                const h = playerHammers[id];
                h.frames--;
                if (h.frames <= 0) delete playerHammers[id];
            }
        }

        // ========== ì‚¬ë¬´ë¼ì´ ë°˜ê²© ëŒì§„ ì‹œì‘ ==========
        function _startSamuraiCounter() {
            samuraiCounterActive = true;
            samuraiCounterFrames = SAMURAI_COUNTER_FRAMES;
            samuraiCounterHitIds.clear();
            // â˜… íŒ¨ë§ ì‚¬ìš© ìˆœê°„ ì €ì¥ëœ ë°©í–¥ ê·¸ëŒ€ë¡œ ì‚¬ìš© (ë§ˆìš°ìŠ¤ ì¬ê³„ì‚° ì—†ìŒ)
            samuraiCounterVx = Math.cos(samuraiParryDir) * SAMURAI_COUNTER_SPEED;
            samuraiCounterVy = Math.sin(samuraiParryDir) * SAMURAI_COUNTER_SPEED;
            // Firebase ê³µìœ : ë°˜ê²© ìŠ¬ë˜ì‹œë¡œ í‘œì‹œ
            const now = Date.now();
            samuraiSlashesRef.child('counter_' + myPlayerId).set({
                ownerId: myPlayerId, type: 'counter',
                dir: samuraiParryDir, totalFrames: SAMURAI_COUNTER_FRAMES, createdAt: now
            });
            playerSamuraiSlashes['counter_' + myPlayerId] = {
                ownerId: myPlayerId, type: 'counter',
                dir: samuraiParryDir, totalFrames: SAMURAI_COUNTER_FRAMES,
                frames: SAMURAI_COUNTER_FRAMES, angle: samuraiParryDir, createdAt: now
            };
        }

        // ========== ì‚¬ë¬´ë¼ì´ ì—…ë°ì´íŠ¸ ==========
        function updateSamurai() {
            if (!myPlayerId || !players[myPlayerId] || myClass !== 'samurai') {
                // ë‹¤ë¥¸ í”Œë ˆì´ì–´ ì‚¬ë¬´ë¼ì´ ìŠ¬ë˜ì‹œ ì• ë‹ˆë©”ì´ì…˜ ì§„í–‰
                for (const key in playerSamuraiSlashes) {
                    const s = playerSamuraiSlashes[key];
                    if (s.ownerId === myPlayerId) continue;
                    s.progress = 1 - s.frames / s.totalFrames;
                    s.frames--;
                    if (s.frames <= 0) delete playerSamuraiSlashes[key];
                }
                return;
            }

            const myPlayer = players[myPlayerId];
            const cx = myPlayer.x + PLAYER_SIZE / 2;
            const cy = myPlayer.y + PLAYER_SIZE / 2;

            // â”€â”€ ë°˜ê²© ëŒì§„ â”€â”€
            if (samuraiCounterActive && samuraiCounterFrames > 0) {
                myPlayer.x = Math.max(0, Math.min(1500 - PLAYER_SIZE, myPlayer.x + samuraiCounterVx));
                myPlayer.y = Math.max(0, Math.min(1500 - PLAYER_SIZE, myPlayer.y + samuraiCounterVy));
                const _dcNow = Date.now();
                if (_dcNow - _lastPosWrite >= 50) { _lastPosWrite = _dcNow; playersRef.child(myPlayerId).update({ x: myPlayer.x, y: myPlayer.y }); }

                // ê²½ë¡œìƒ ì  í”¼í•´ (ëŒì§„ ì¤‘ ì ‘ì´‰ íŒì •)
                for (let id in players) {
                    if (id === myPlayerId || samuraiCounterHitIds.has(id)) continue;
                    const t = players[id];
                    if (t.isSpectator || t.health <= 0) continue;
                    const tx = t.x + PLAYER_SIZE / 2;
                    const ty = t.y + PLAYER_SIZE / 2;
                    const dist = Math.sqrt((myPlayer.x + PLAYER_SIZE/2 - tx)**2 + (myPlayer.y + PLAYER_SIZE/2 - ty)**2);
                    if (dist < PLAYER_SIZE + 10) {
                        samuraiCounterHitIds.add(id);
                        dealDamage(id, Math.round(CLASSES.samurai.stats.attack * SAMURAI_COUNTER_DMG_PCT), tx, ty, true);
                    }
                }

                samuraiCounterFrames--;
                if (samuraiCounterFrames <= 0) {
                    // â˜… ëŒì§„ ì¢…ë£Œ ì‹œ ë„“ì€ ì›í˜• ë²”ìœ„ í­ë°œ í”¼í•´
                    const COUNTER_BURST_RADIUS = 170;  // ì›Œë¦¬ì–´ 360ë„ ë² ê¸°(WARRIOR_SPIN_RANGE)ì™€ ë™ì¼
                    const cx = myPlayer.x + PLAYER_SIZE / 2;
                    const cy = myPlayer.y + PLAYER_SIZE / 2;
                    for (let id in players) {
                        if (id === myPlayerId || samuraiCounterHitIds.has(id)) continue;
                        const t = players[id];
                        if (t.isSpectator || t.health <= 0) continue;
                        const tx = t.x + PLAYER_SIZE / 2;
                        const ty = t.y + PLAYER_SIZE / 2;
                        const dist = Math.sqrt((cx - tx)**2 + (cy - ty)**2);
                        if (dist < COUNTER_BURST_RADIUS) {
                            samuraiCounterHitIds.add(id);
                            dealDamage(id, Math.round(CLASSES.samurai.stats.attack * SAMURAI_COUNTER_DMG_PCT), tx, ty, true);
                        }
                    }
                    // í”¼í•´ ë²”ìœ„ ì› í‘œì‹œ (Firebaseë¡œ ëª¨ë“  í”Œë ˆì´ì–´ì—ê²Œ ê³µìœ )
                    const burstNow = Date.now();
                    samuraiSlashesRef.child('burst_' + myPlayerId).set({
                        ownerId: myPlayerId, type: 'burst',
                        x: cx, y: cy,
                        radius: COUNTER_BURST_RADIUS,
                        createdAt: burstNow
                    });
                    playerSamuraiSlashes['burst_' + myPlayerId] = {
                        ownerId: myPlayerId, type: 'burst',
                        x: cx, y: cy,
                        radius: COUNTER_BURST_RADIUS,
                        frames: 20, totalFrames: 20, createdAt: burstNow
                    };
                    // ë‚´ burstë„ ë§¤ í”„ë ˆì„ ê°ì†Œ (updateSamurai ë£¨í”„ê°€ ownerId===myPlayerId ìŠ¤í‚µí•˜ë¯€ë¡œ ì§ì ‘ ì²˜ë¦¬)
                    const _burstKey = 'burst_' + myPlayerId;
                    const _burstDecay = setInterval(() => {
                        if (!playerSamuraiSlashes[_burstKey]) { clearInterval(_burstDecay); return; }
                        playerSamuraiSlashes[_burstKey].frames--;
                        if (playerSamuraiSlashes[_burstKey].frames <= 0) {
                            clearInterval(_burstDecay);
                        }
                    }, 1000/60);
                    setTimeout(() => {
                        clearInterval(_burstDecay);
                        samuraiSlashesRef.child('burst_' + myPlayerId).remove();
                        delete playerSamuraiSlashes['burst_' + myPlayerId];
                    }, 700);
                    samuraiCounterActive = false;
                    samuraiCounterHitIds.clear();
                    samuraiSlashesRef.child('counter_' + myPlayerId).remove();
                    delete playerSamuraiSlashes['counter_' + myPlayerId];
                }
            }

            // â”€â”€ ì°Œë¥´ê¸° â”€â”€
            if (samuraiSlashActive) {
                samuraiSlashProgress = 1 - samuraiSlashFrames / SAMURAI_SLASH_TOTAL;

                // ëŒì§„
                if (samuraiSlashDashFrames > 0) {
                    myPlayer.x = Math.max(0, Math.min(1500 - PLAYER_SIZE, myPlayer.x + samuraiSlashDashVx));
                    myPlayer.y = Math.max(0, Math.min(1500 - PLAYER_SIZE, myPlayer.y + samuraiSlashDashVy));
                    const _dsNow = Date.now();
                    if (_dsNow - _lastPosWrite >= 50) { _lastPosWrite = _dsNow; playersRef.child(myPlayerId).update({ x: myPlayer.x, y: myPlayer.y }); }
                    samuraiSlashDashFrames--;
                }

                // ë Œë”ë§ìš© ë‚´ ìŠ¬ë˜ì‹œ ìƒíƒœ ê°±ì‹ 
                const _lvl = samuraiCurrentLevel || SAMURAI_CHARGE_LEVELS[3];
                playerSamuraiSlashes[myPlayerId] = {
                    ownerId: myPlayerId, type: 'slash',
                    dir: samuraiSlashDir, totalFrames: SAMURAI_SLASH_TOTAL,
                    frames: samuraiSlashFrames, progress: samuraiSlashProgress,
                    thrustLength: _lvl.length, thrustWidth: _lvl.width,
                    createdAt: playerSamuraiSlashes[myPlayerId]?.createdAt || Date.now()
                };

                // íˆíŠ¸ íŒì • (ì§ì‚¬ê°í˜• ì°Œë¥´ê¸°) - progress > 0.25ë¶€í„°
                if (samuraiSlashProgress > 0.25) {
                    const lvl = samuraiCurrentLevel || SAMURAI_CHARGE_LEVELS[3];
                    const thrustLength = lvl.length * samuraiSlashProgress;
                    const halfW = lvl.width / 2 + PLAYER_SIZE / 2;
                    const dirX = Math.cos(samuraiSlashDir);
                    const dirY = Math.sin(samuraiSlashDir);

                    for (let id in players) {
                        if (id === myPlayerId || samuraiSlashHitIds.has(id)) continue;
                        const t = players[id];
                        if (t.isSpectator || t.health <= 0) continue;
                        const tx = t.x + PLAYER_SIZE / 2;
                        const ty = t.y + PLAYER_SIZE / 2;

                        const relX = tx - (myPlayer.x + PLAYER_SIZE / 2);
                        const relY = ty - (myPlayer.y + PLAYER_SIZE / 2);
                        const parallelDist = relX * dirX + relY * dirY;
                        const perpDist = Math.abs(-relY * dirX + relX * dirY);

                        // ì‹œì‘ì ì„ -PLAYER_SIZEê¹Œì§€ í™•ì¥í•´ ëŒì§„ í›„ ë°”ë¡œ ë¶™ì€ ì ë„ íŒì •
                        if (parallelDist >= -PLAYER_SIZE && parallelDist <= thrustLength && perpDist < halfW) {
                            samuraiSlashHitIds.add(id);
                            // ì°¨ì§• dmgë¥¼ ê³µê²©ë ¥ % ë¹„ë¡€ë¡œ ê³„ì‚° (ê¸°ë³¸ ê³µê²©ë ¥ 20 ê¸°ì¤€, lvl.dmg/20 = pct)
                            const thrustDmg = Math.round(CLASSES.samurai.stats.attack * (lvl.dmg / 20));
                            dealDamage(id, thrustDmg, tx, ty);
                        }
                    }
                }

                samuraiSlashFrames--;
                if (samuraiSlashFrames <= 0) {
                    samuraiSlashActive = false;
                    samuraiSlashHitIds.clear();
                    delete playerSamuraiSlashes[myPlayerId];
                    samuraiSlashesRef.child(myPlayerId).remove();
                }
            }

            // â”€â”€ ë‹¤ë¥¸ í”Œë ˆì´ì–´ ìŠ¬ë˜ì‹œ ì• ë‹ˆë©”ì´ì…˜ â”€â”€
            for (const key in playerSamuraiSlashes) {
                const s = playerSamuraiSlashes[key];
                if (s.ownerId === myPlayerId) continue;
                // burst/counter/slash ëª¨ë‘ frames ê°ì†Œ
                s.frames--;
                if (s.frames <= 0) {
                    delete playerSamuraiSlashes[key];
                } else if (s.type !== 'counter' && s.type !== 'burst') {
                    s.progress = 1 - s.frames / s.totalFrames;
                }
            }
        }

        // ========== ì¤‘ì•™ í”¼í•´ ì²˜ë¦¬ í•¨ìˆ˜ ==========
        // ëª¨ë“  ê³µê²©ì€ ë°˜ë“œì‹œ ì´ í•¨ìˆ˜ë¥¼ í†µí•´ í”¼í•´ë¥¼ ì¤Œ.
        // íŒ¨ë§ì€ ì—¬ê¸°ì„œ HPë¥¼ ê±´ë“œë¦¬ê¸° ì „ì— ë¨¼ì € ì°¨ë‹¨ â†’ ë”¸í”¼ì—¬ë„ ì•ˆì „.
        // í–¥í›„ ì§ì—… ì¶”ê°€ ì‹œ dealDamageë§Œ ì“°ë©´ ìë™ìœ¼ë¡œ íŒ¨ë§ ì ìš©ë¨.
        function dealDamage(targetId, dmg, hitX, hitY, isFixedDmg = false) {
            const target = players[targetId];
            if (!target || target.isSpectator || target.health <= 0) return;

            // ë¶„ë…¸ ê³µê²©ë ¥ ë³´ë„ˆìŠ¤ (ê³ ì • í”¼í•´ ì œì™¸ â€” ì¥íŒ, íŒ¨ë§ ë°˜ê²© ë“±)
            const actualDmg = (rageActive && !isFixedDmg) ? dmg + 10 : dmg;

            // â”€â”€ ì‚¬ë¬´ë¼ì´ íŒ¨ë§: HP ê±´ë“œë¦¬ê¸° ì „ì— ë¨¼ì € ì°¨ë‹¨ â”€â”€
            if (target.samuraiParrying) {
                // íˆíŠ¸ ì´í™íŠ¸ ì—†ìŒ (íŒ¨ë§ ë§‰ì•˜ëŠ”ë° ë§ëŠ” ëŠë‚Œ ë°©ì§€)
                parryHitsRef.child(targetId).set({ targetId, createdAt: Date.now() });
                setTimeout(() => parryHitsRef.child(targetId).remove(), 1000);
                return;
            }

            // â”€â”€ í—ˆìˆ˜ì•„ë¹„ í”¼ê²©: ë°ë¯¸ì§€/DPS ì¸¡ì • â”€â”€
            if (targetId === DUMMY_ID && gameMode === GAME_MODE.PRACTICE) {
                const now = Date.now();
                dummyDmgTotal += actualDmg;
                dummyLastHit = actualDmg;
                dummyDmgWindow.push({ time: now, dmg: actualDmg });
                dummyFloatingNums.push({
                    x: hitX, y: hitY,
                    dmg: actualDmg, life: 1.0, vy: -1.5
                });
                spawnHitEffect(hitX, hitY, false);
                return;
            }

            const newHp = Math.max(0, target.health - actualDmg);
            const isFatal = newHp <= 0;
            playersRef.child(targetId).update({ health: newHp });
            if (isFatal) playersRef.child(targetId).update({ isSpectator: true });
            spawnHitEffect(hitX, hitY, isFatal);
        }

        // â”€â”€ í—ˆìˆ˜ì•„ë¹„ DPS ê³„ì‚° ì—…ë°ì´íŠ¸ â”€â”€
        function updateDummyDps() {
            const now = Date.now();
            dummyDmgWindow = dummyDmgWindow.filter(e => now - e.time <= 1000);
            dummyDps = dummyDmgWindow.reduce((sum, e) => sum + e.dmg, 0);
        }

        // â”€â”€ í—ˆìˆ˜ì•„ë¹„ í”Œë¡œíŒ… ë°ë¯¸ì§€ ìˆ«ì ì—…ë°ì´íŠ¸ â”€â”€
        function updateDummyFloatingNums() {
            for (let i = dummyFloatingNums.length - 1; i >= 0; i--) {
                const n = dummyFloatingNums[i];
                n.y += n.vy;
                n.life -= 0.03;
                if (n.life <= 0) dummyFloatingNums.splice(i, 1);
            }
        }

        // â”€â”€ í—ˆìˆ˜ì•„ë¹„ ì´ì•Œ ë°œì‚¬ (ì•„ë˜ ë°©í–¥ ê³ ì •, ëŠë¦¼) â”€â”€
        function updateDummyShoot() {
            if (!players[DUMMY_ID]) return;
            dummyShootTimer++;
            if (dummyShootTimer < DUMMY_SHOOT_INTERVAL) return;
            dummyShootTimer = 0;
            const dummy = players[DUMMY_ID];
            const startX = dummy.x + PLAYER_SIZE / 2;
            const startY = dummy.y + PLAYER_SIZE / 2;
            // ì•„ë˜ ë°©í–¥ ê³ ì •
            const dirX = 0;
            const dirY = 1;
            const now = Date.now();
            const bulletData = {
                id: DUMMY_ID + '_bullet_' + now,
                x: startX,
                y: startY + PLAYER_SIZE,
                vx: dirX * DUMMY_BULLET_SPEED,
                vy: dirY * DUMMY_BULLET_SPEED,
                damage: DUMMY_BULLET_DMG,
                ownerId: DUMMY_ID,
                createdAt: now,
                maxLifetime: 5000,
                isSkillBullet: false,
                isDummyBullet: true
            };
            bulletIds.add(bulletData.id);
            bullets.push(bulletData);
            bulletsRef.child(bulletData.id).set(bulletData);
            setTimeout(() => bulletsRef.child(bulletData.id).remove(), 5500);
        }

        // â”€â”€ íŒ¨ë§ ë°˜ê²© íŠ¸ë¦¬ê±° â”€â”€
        // í”¼ê²©ì ë³¸ì¸ í´ë¼ì´ì–¸íŠ¸ì—ì„œ hitEffectsRefë¥¼ í†µí•´ íŒ¨ë§ íˆíŠ¸ ì‹ í˜¸ë¥¼ ë°›ì•„ ë°˜ê²©.
        // dealDamageê°€ HPë¥¼ ê±´ë“œë¦¬ì§€ ì•Šìœ¼ë¯€ë¡œ HP ë¦¬ìŠ¤ë„ˆë¡œëŠ” ê°ì§€ ë¶ˆê°€.
        // ëŒ€ì‹  ê³µê²©ìê°€ dealDamageì—ì„œ íŒ¨ë§ì„ ê°ì§€í•˜ë©´ parryHitRefì— ì‹ í˜¸ë¥¼ ìœë‹¤.
        function _checkAndTriggerParry() {
            if (myClass !== 'samurai' || !samuraiParryActive || samuraiParryHit) return;
            samuraiParryHit = true;
            samuraiParryActive = false;
            playersRef.child(myPlayerId).update({ samuraiParrying: false });
            samuraiSlashesRef.child('parry_' + myPlayerId).remove();
            _startSamuraiCounter();
        }
        function spawnForgeEnhanceEffect(x, y) {
            const now = Date.now();
            const cx = x + PLAYER_SIZE / 2;
            const cy = y + PLAYER_SIZE / 2;
            // í™©ê¸ˆ íŒŒí‹°í´: ë¡œì»¬ 15ê°œ ì‹œê° íš¨ê³¼ + FirebaseëŠ” 8ê°œë§Œ ê³µìœ 
            for (let i = 0; i < 15; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 1.5;
                const p = {
                    id: myPlayerId + '_forge_' + now + '_' + i,
                    ownerId: myPlayerId,
                    x: cx + (Math.random() - 0.5) * 20,
                    y: cy + (Math.random() - 0.5) * 20,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 1.5,
                    radius: Math.random() * 6 + 3,
                    life: 1.0,
                    decay: 0.03 + Math.random() * 0.03,
                    createdAt: now,
                    color: i % 2 === 0 ? '#ffd700' : '#ff8c00'
                };
                particleIds.add(p.id);
                particles.push(p);
                if (i < 8) { // Firebase ì—…ë¡œë“œëŠ” 8ê°œë§Œ
                    particlesRef.child(p.id).set(p);
                    setTimeout(() => { try { particlesRef.child(p.id).remove(); } catch(e){} }, 2500);
                }
            }
        }

        // ========== ì£¼ëª½ ì—…ë°ì´íŠ¸ ==========
        function updateJumong() {
            // í˜¸í¬ì•„ì´ ë§Œë£Œ ì²´í¬
            if (jumongHawkeyeActive && Date.now() > jumongHawkeyeEnd) {
                jumongHawkeyeActive = false;
                if (myPlayerId) playersRef.child(myPlayerId).update({ jumongHawkeye: false });
            }
            // ë‹¤ë¥¸ í”Œë ˆì´ì–´ í™”ì‚´ ì‹œê° ì´í™íŠ¸ í˜ì´ë“œ
            for (const id in playerJumongArrows) {
                const a = playerJumongArrows[id];
                a.x += a.vx;
                a.y += a.vy;
                const elapsed = Date.now() - a.createdAt;
                a.life = Math.max(0, 1 - elapsed / a.maxLifetime);
                if (a.life <= 0) delete playerJumongArrows[id];
            }
        }

        // ========== ë¬´í¬ ì—…ë°ì´íŠ¸ ==========
        function updateMuhui() {
            if (!muhuiZoneActive || !myPlayerId || !players[myPlayerId] || myClass !== 'muhui') return;

            const myPlayer = players[myPlayerId];
            const nx = myPlayer.x + PLAYER_SIZE / 2;
            const ny = myPlayer.y + PLAYER_SIZE / 2;

            // ì¥íŒ ìœ„ì¹˜ë¥¼ í”Œë ˆì´ì–´ ìœ„ì¹˜ë¡œ ë§¤ í”„ë ˆì„ ê°±ì‹  (ë¡œì»¬)
            if (playerMuhuiZones[myPlayerId]) {
                playerMuhuiZones[myPlayerId].x = nx;
                playerMuhuiZones[myPlayerId].y = ny;
            }
            // Firebaseì— ìœ„ì¹˜ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ (30í”„ë ˆì„ë§ˆë‹¤ = ~0.5ì´ˆ)
            muhuiZoneDmgTimer++;
            if (muhuiZoneDmgTimer % 30 === 0) {
                muhuiZonesRef.child(myPlayerId).update({ x: nx, y: ny });
            }

            // 1ì´ˆ(60í”„ë ˆì„)ë§ˆë‹¤ í”¼í•´ í‹±
            if (muhuiZoneDmgTimer >= 60) {
                muhuiZoneDmgTimer = 0;
                const zone = playerMuhuiZones[myPlayerId];
                if (zone) {
                    for (let id in players) {
                        if (id === myPlayerId) continue;
                        const t = players[id];
                        if (t.isSpectator || t.health <= 0) continue;
                        const tx = t.x + PLAYER_SIZE / 2;
                        const ty = t.y + PLAYER_SIZE / 2;
                        const dist = Math.sqrt((tx - nx)**2 + (ty - ny)**2);
                        if (dist < zone.radius + PLAYER_SIZE / 2) {
                            dealDamage(id, MUHUI_ZONE_DPS, tx, ty, true);
                        }
                    }
                }
            }
        }

        // ========== ì´ì•Œ ì—…ë°ì´íŠ¸ ==========
        function updateBullets() {
            const now = Date.now();
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.x += bullet.vx;
                bullet.y += bullet.vy;

                // ìˆ˜ëª… ì´ˆê³¼
                if (now - bullet.createdAt > bullet.maxLifetime) {
                    if (bullet.ownerId === myPlayerId) bulletsRef.child(bullet.id).remove();
                    bulletIds.delete(bullet.id);
                    bullets.splice(i, 1);
                    continue;
                }
                // ë§µ ë°–
                if (bullet.x < -100 || bullet.x > 1600 || bullet.y < -100 || bullet.y > 1600) {
                    if (bullet.ownerId === myPlayerId) bulletsRef.child(bullet.id).remove();
                    bulletIds.delete(bullet.id);
                    bullets.splice(i, 1);
                    continue;
                }

                // ===== ì¶©ëŒ ê°ì§€ =====
                // í—ˆìˆ˜ì•„ë¹„ ì´ì•Œ
                if (bullet.ownerId === DUMMY_ID && bullet.isDummyBullet) {
                    if (myPlayerId && players[myPlayerId] && isAlive) {
                        const me = players[myPlayerId];
                        const tx = me.x + PLAYER_SIZE / 2;
                        const ty = me.y + PLAYER_SIZE / 2;
                        const dist = Math.sqrt((bullet.x - tx)**2 + (bullet.y - ty)**2);
                        if (dist < PLAYER_SIZE / 2 + 6) {
                            dealDamage(myPlayerId, bullet.damage, bullet.x, bullet.y);
                            bulletsRef.child(bullet.id).remove();
                            bulletIds.delete(bullet.id);
                            bullets.splice(i, 1);
                        }
                    }
                    continue;
                }
                if (bullet.ownerId !== myPlayerId) continue;
                for (let id in players) {
                    if (id === bullet.ownerId) continue;
                    const target = players[id];
                    if (target.isSpectator || target.health <= 0) continue;
                    // ëª¨ë˜ì‹œê³„ ë¬´ì 
                    if (target.hourglassActive) continue;
                    const tx = target.x + PLAYER_SIZE / 2;
                    const ty = target.y + PLAYER_SIZE / 2;
                    const dist = Math.sqrt((bullet.x - tx) ** 2 + (bullet.y - ty) ** 2);
                    if (dist < PLAYER_SIZE / 2 + (bullet.isSkillBullet ? 6 : 4)) {
                        // ì›Œë¦¬ì–´ ìŠ¤í‚¬ ì¤‘ì´ë©´ í”¼í•´ 50% ê°ì†Œ
                        let dmg = bullet.damage;
                        if (target.warriorSkillActive) dmg = Math.ceil(dmg * 0.5);
                        dealDamage(id, dmg, bullet.x, bullet.y);

                        bulletsRef.child(bullet.id).remove();
                        bulletIds.delete(bullet.id);
                        bullets.splice(i, 1);
                        break;
                    }
                }
            }
        }

        // ========== ê´€ì „ ëŒ€ìƒ ì„ íƒ ==========
        function pickRandomSpectateTarget() {
            const alivePlayers = Object.keys(players).filter(id =>
                id !== myPlayerId && id !== DUMMY_ID && !players[id].isSpectator && players[id].health > 0
            );
            if (alivePlayers.length === 0) {
                spectateTargetId = null;
                return;
            }
            const randomIdx = Math.floor(Math.random() * alivePlayers.length);
            spectateTargetId = alivePlayers[randomIdx];
        }

        // ========== ê²Œì„ ê°•ì œ ì¢…ë£Œ (ëˆ„êµ¬ë‚˜) ==========
        function stopGame() {
            if (isHost && currentRoomId) {
                database.ref('rooms/' + currentRoomId).remove();
            } else {
                gameStateRef.update({ status: GAME_STATUS.LOBBY });
                playersRef.remove();
            }
            location.reload();
        }

        // ========== ê²Œì„ ë£¨í”„ ==========
        let _gameLoopId = null;
        let _gameLoopRunning = false;
        function gameLoop() {
            if (gameStatus !== GAME_STATUS.PLAYING) return;
            _gameLoopId = requestAnimationFrame(gameLoop);
            try {
                update();
                render();
            } catch(e) {
                console.warn('gameLoop error:', e);
            }
        }

        function update() {
            // Rí‚¤ í™€ë“œ â†’ ê°•ì œ ì¢…ë£Œ ì²´í¬ (ëˆ„êµ¬ë‚˜)
            if (rKeyHolding && gameStatus === GAME_STATUS.PLAYING) {
                const held = Date.now() - rKeyPressStart;
                forceStopProgress = Math.min(100, (held / 3000) * 100);
                if (held >= 3000) {
                    rKeyHolding = false;
                    stopGame();
                    return;
                }
            }

            // â”€â”€ ë‹¤ë¥¸ í”Œë ˆì´ì–´ ìœ„ì¹˜ ì˜ˆì¸¡ ë³´ê°„ (dead-reckoning) â”€â”€
            const _drNow = Date.now();
            for (const id in playerRenderPos) {
                const rp = playerRenderPos[id];
                if (rp.tx === undefined) continue;
                // dead-reckoning: ë§ˆì§€ë§‰ ìˆ˜ì‹  ì´í›„ ê²½ê³¼ ì‹œê°„ë§Œí¼ ì†ë„ ë²¡í„°ë¡œ ëª©í‘œ ìœ„ì¹˜ ì˜ˆì¸¡
                const _sinceUpdate = _drNow - (rp.lastT || _drNow);
                const predX = rp.tx + (rp.vx || 0) * Math.min(_sinceUpdate, 80);
                const predY = rp.ty + (rp.vy || 0) * Math.min(_sinceUpdate, 80);
                const dx = predX - rp.x;
                const dy = predY - rp.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                // ê°€ê¹Œìš°ë©´ ì¦‰ì‹œ ìŠ¤ëƒ…, ë©€ë©´ ë¹ ë¥´ê²Œ lerp
                if (dist < 2) {
                    rp.x = predX;
                    rp.y = predY;
                } else {
                    const speed = Math.min(0.55, 8 / dist + 0.3);
                    rp.x += dx * speed;
                    rp.y += dy * speed;
                }
            }

            // ê´€ì „ ëª¨ë“œ ì¹´ë©”ë¼
            if (isSpectating || !isAlive) {
                if (spectateTargetId && players[spectateTargetId]) {
                    const target = players[spectateTargetId];
                    cameraX = target.x - canvas.width / 2 + PLAYER_SIZE / 2;
                    cameraY = target.y - canvas.height / 2 + PLAYER_SIZE / 2;
                }
                updateBullets();
                updateParticles();
                updateHitEffects();
                updateWarriorSwing();  // ì›Œë¦¬ì–´ ìŠ¤ìœ™ë„ ì—…ë°ì´íŠ¸ (ë‹¤ë¥¸ í”Œë ˆì´ì–´ ì• ë‹ˆë©”ì´ì…˜)
                updateAssassinStab();  // ì–´ìŒ”ì‹  ì°Œë¥´ê¸° ì• ë‹ˆë©”ì´ì…˜
                updateSmokeParticles(); // ì—°ê¸° íŒŒí‹°í´
                updateSmithHammer();   // ëŒ€ì¥ì¥ì´ ë§ì¹˜ ê³µê²© ì• ë‹ˆë©”ì´ì…˜
                updateSamurai();       // ì‚¬ë¬´ë¼ì´ ë² ê¸°/íŒ¨ë§/ë°˜ê²© ì• ë‹ˆë©”ì´ì…˜
                updateCooldownHUD();
                document.getElementById('spectateHint').style.display = 'block';
                return;
            }

            if (!myPlayerId || !players[myPlayerId]) return;
            
            const myPlayer = players[myPlayerId];
            const stats = CLASSES[myClass].stats;
            let moved = false;

            // ì´ë™ì†ë„ (ì›Œë¦¬ì–´ ìŠ¤í‚¬ ì‹œ +1.5 ì¦ê°€, ì–´ìŒ”ì‹  ì€ì‹  ì‹œ 2ë°°, ëŒ€ì¥ì¥ì´ ê²½ì§ ì‹œ 0, ëª¨ë˜ì‹œê³„ ì‹œ 0)
            const curSpeed = (smithForging || samuraiParryActive || hourglassActive)
                ? 0
                : (myClass === 'warrior' && warriorSkillActive)
                ? stats.moveSpeed + 1.5
                : (myClass === 'assassin' && assassinStealthActive)
                ? stats.moveSpeed * 2
                : stats.moveSpeed + (fluidActive ? fluidBonus : 0);

            // ëŒì§„ ì²˜ë¦¬
            if (samuraiCounterActive) {
                // ì‚¬ë¬´ë¼ì´ ë°˜ê²© ëŒì§„ ì¤‘ â€” updateSamuraiì—ì„œ ì²˜ë¦¬
                moved = true;
            } else if (isDashing && dashRemainFrames > 0) {
                spawnDashParticles(myPlayer.x, myPlayer.y);
                myPlayer.x += dashVx;
                myPlayer.y += dashVy;
                myPlayer.x = Math.max(0, Math.min(1500 - PLAYER_SIZE, myPlayer.x));
                myPlayer.y = Math.max(0, Math.min(1500 - PLAYER_SIZE, myPlayer.y));
                dashRemainFrames--;
                moved = true;
                if (dashRemainFrames <= 0) isDashing = false;
            } else {
                if (keys['w'] || keys['ã…ˆ']) { myPlayer.y -= curSpeed; moved = true; }
                if (keys['s'] || keys['ã„´']) { myPlayer.y += curSpeed; moved = true; }
                if (keys['a'] || keys['ã…']) { myPlayer.x -= curSpeed; moved = true; }
                if (keys['d'] || keys['ã„¹']) { myPlayer.x += curSpeed; moved = true; }
                myPlayer.x = Math.max(0, Math.min(1500 - PLAYER_SIZE, myPlayer.x));
                myPlayer.y = Math.max(0, Math.min(1500 - PLAYER_SIZE, myPlayer.y));
            }
            
            // ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸ (í•­ìƒ í”Œë ˆì´ì–´ ì¤‘ì•™, ì¤Œì€ render()ì—ì„œ ctx.scaleë¡œë§Œ ì²˜ë¦¬)
            cameraX = myPlayer.x - canvas.width  / 2 + PLAYER_SIZE / 2;
            cameraY = myPlayer.y - canvas.height / 2 + PLAYER_SIZE / 2;
            // ì¤Œ ë³´ê°„ (ë¶€ë“œëŸ¬ìš´ ìŠˆìš± íš¨ê³¼)
            const _lerpSpeed = 0.06;
            jumongCurrentZoom += (jumongTargetZoom - jumongCurrentZoom) * _lerpSpeed;
            if (Math.abs(jumongCurrentZoom - jumongTargetZoom) < 0.001) jumongCurrentZoom = jumongTargetZoom;
            
            if (moved) {
                const _now = Date.now();
                if (_now - _lastPosWrite >= 50) { // 20fps ì“°ë¡œí‹€ (ë¡œì»¬ì€ ì¦‰ì‹œ ë°˜ì˜ë¨)
                    _lastPosWrite = _now;
                    playersRef.child(myPlayerId).update({ x: myPlayer.x, y: myPlayer.y, timestamp: _now });
                }
            }
            
            if (!_domMyHealth) _domMyHealth = document.getElementById('myHealth');
            if (_domMyHealth) _domMyHealth.textContent = `${myPlayer.health}/${myPlayer.maxHealth}`;
            
            // ì–´ìŒ”ì‹  ì€ì‹  ë§Œë£Œ ì²´í¬
            if (myClass === 'assassin' && assassinStealthActive && Date.now() > assassinStealthEnd) {
                assassinStealthActive = false;
                playersRef.child(myPlayerId).update({ stealthed: false });
            }

            // ì›Œë¦¬ì–´ ì „íˆ¬íƒœì„¸ ë§Œë£Œ ì²´í¬ (ë§¤ í”„ë ˆì„, íšŒì „ë² ê¸° íˆíŠ¸ ì‹œ ë¦¬ì…‹ë˜ë¯€ë¡œ setTimeout ë¯¸ì‚¬ìš©)
            if (myClass === 'warrior' && warriorSkillActive && Date.now() > warriorSkillEnd) {
                warriorSkillActive = false;
                warriorSpinReady = false;
                playersRef.child(myPlayerId).update({ warriorSkillActive: false });
            }

            updateSkill();
            updateWarriorSwing();
            updateAssassinStab();
            updateSmokeParticles();
            updateSmithHammer();
            updateSamurai();
            updateBullets();
            updateParticles();
            updateHitEffects();
            updateSpells();
            updateCooldownHUD();
            if (gameMode === GAME_MODE.PRACTICE) {
                updateDummyDps();
                updateDummyShoot();
                updateDummyFloatingNums();
            }
            updateJumong();
            updateMuhui();
        }

        function render() {
            // ì„±ëŠ¥: ê¸°ë³¸ shadow OFF (ctx.save/restoreê°€ shadowë¥¼ ìë™ ë¦¬ì…‹ ì•ˆ í•¨)
            ctx.shadowBlur = 0;
            ctx.shadowColor = 'transparent';

            // â”€â”€ ì¤Œ ê³„ì‚° â”€â”€
            // _z: í˜„ì¬ ì¤Œ ë°°ìœ¨ (1.0 = ê¸°ë³¸, >1 = ì‹œì•¼ í™•ëŒ€)
            // cameraX_r: ì¤Œ ë°˜ì˜ ì¹´ë©”ë¼ ì˜¤í”„ì…‹
            //   í”Œë ˆì´ì–´ê°€ í•­ìƒ í™”ë©´ ì¤‘ì•™ì´ ë˜ë ¤ë©´:
            //   ctx.scale(1/_z) ì ìš© í›„ (worldX - cameraX_r) ê°€ canvas.width/2 ì´ ë˜ì–´ì•¼ í•¨
            //   â†’ cameraX_r = player.x - canvas.width*_z/2
            const _z = jumongCurrentZoom;
            let cameraX_r = cameraX;
            let cameraY_r = cameraY;
            if (_z !== 1.0 && myPlayerId && players[myPlayerId]) {
                cameraX_r = players[myPlayerId].x + PLAYER_SIZE / 2 - (canvas.width  * _z) / 2;
                cameraY_r = players[myPlayerId].y + PLAYER_SIZE / 2 - (canvas.height * _z) / 2;
            }

            // ë°°ê²½ (scale ì „, í•­ìƒ ì „ì²´ í™”ë©´)
            ctx.fillStyle = '#0f3460';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ê²Œì„ ì”¬ ì „ì²´ì— ì¤Œ scale ì ìš© (save/restoreë¡œ HUDì™€ ë¶„ë¦¬)
            ctx.save();
            if (_z !== 1.0) {
                ctx.scale(1 / _z, 1 / _z);
            }

            // ë§µ ì¢Œí‘œ (ìŠ¤ì¼€ì¼ ê³µê°„ ê¸°ì¤€)
            const mapScreenX = -cameraX_r;
            const mapScreenY = -cameraY_r;

            // ê·¸ë¦¬ë“œ (ë‹¨ì¼ íŒ¨ìŠ¤ë¡œ ì„±ëŠ¥ ìµœì í™”)
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(0, 255, 245, 0.08)';
            ctx.lineWidth = 1;
            const gridSize = 50;
            const startX = Math.floor(cameraX_r / gridSize) * gridSize;
            const startY = Math.floor(cameraY_r / gridSize) * gridSize;
            const endX = cameraX_r + canvas.width * _z;
            const endY = cameraY_r + canvas.height * _z;
            for (let x = startX; x < endX; x += gridSize) {
                ctx.moveTo(x - cameraX_r, 0);
                ctx.lineTo(x - cameraX_r, canvas.height * _z);
            }
            for (let y = startY; y < endY; y += gridSize) {
                ctx.moveTo(0, y - cameraY_r);
                ctx.lineTo(canvas.width * _z, y - cameraY_r);
            }
            ctx.stroke();

            // ë§µ ê²½ê³„ì„ 
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 100, 100, 0.7)';
            ctx.lineWidth = 3;
            ctx.strokeRect(mapScreenX, mapScreenY, MAP_W, MAP_H);
            // ë§µ ë°– ì˜¤ë²„ë ˆì´
            const _vW = canvas.width * _z;
            const _vH = canvas.height * _z;
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            if (mapScreenY > 0) ctx.fillRect(0, 0, _vW, mapScreenY);
            if (mapScreenY + MAP_H < _vH) ctx.fillRect(0, mapScreenY + MAP_H, _vW, _vH - mapScreenY - MAP_H);
            if (mapScreenX > 0) ctx.fillRect(0, mapScreenY, mapScreenX, MAP_H);
            if (mapScreenX + MAP_W < _vW) ctx.fillRect(mapScreenX + MAP_W, mapScreenY, _vW - mapScreenX - MAP_W, MAP_H);
            ctx.restore();

            
            // â”€â”€ ë¬´í¬ ì¥íŒ (í”Œë ˆì´ì–´ ì•„ë˜ì— í‘œì‹œ) â”€â”€
            for (const ownerId in playerMuhuiZones) {
                const zone = playerMuhuiZones[ownerId];
                const elapsed = Date.now() - zone.createdAt;
                const remaining = Math.max(0, zone.duration - elapsed);
                const lifeRatio = remaining / zone.duration;
                if (lifeRatio <= 0) continue;
                const zx = zone.x - cameraX_r;
                const zy = zone.y - cameraY_r;
                ctx.save();
                const wave = 0.08 * Math.sin(Date.now() / 220);
                // ì±„ìš°ê¸° (ë§¤ìš° ì—°í•˜ê²Œ)
                ctx.globalAlpha = 0.13 + wave;
                ctx.fillStyle = '#ffaadd';
                ctx.shadowColor = '#ff88cc';
                ctx.shadowBlur = 5;
                ctx.beginPath();
                ctx.arc(zx, zy, zone.radius, 0, Math.PI * 2);
                ctx.fill();
                // í…Œë‘ë¦¬ (ì—°í•œ ì ì„  ëŠë‚Œ)
                ctx.globalAlpha = 0.35 + wave;
                ctx.strokeStyle = '#ffccee';
                ctx.lineWidth = 1.5;
                ctx.shadowBlur = 3;
                ctx.setLineDash([8, 6]);
                ctx.stroke();
                ctx.setLineDash([]);
                // ë‚¨ì€ ì‹œê°„ í˜¸ (ì—°í•œ í…Œë‘ë¦¬)
                ctx.globalAlpha = 0.5;
                ctx.strokeStyle = '#ff99cc';
                ctx.lineWidth = 2;
                ctx.shadowBlur = 2;
                ctx.beginPath();
                ctx.arc(zx, zy, zone.radius, -Math.PI / 2, -Math.PI / 2 + Math.PI * 2 * lifeRatio);
                ctx.stroke();
                // ë‚¨ì€ ì‹œê°„ í…ìŠ¤íŠ¸
                ctx.globalAlpha = 0.7;
                ctx.fillStyle = '#ffddee';
                ctx.font = '11px Malgun Gothic';
                ctx.textAlign = 'center';
                ctx.shadowBlur = 4;
                ctx.fillText('ğŸŒ¸ ' + (remaining / 1000).toFixed(1) + 's', zx, zy + zone.radius + 14);
                ctx.restore();
            }

            // ëª¨ë“  í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸°
            for (let id in players) {
                const player = players[id];
                const isMe = id === myPlayerId;

                // ê´€ì „ìëŠ” ê·¸ë¦¬ì§€ ì•ŠìŒ
                if (player.isSpectator) continue;
                // ì‚¬ë§í•œ í”Œë ˆì´ì–´ë„ ê·¸ë¦¬ì§€ ì•ŠìŒ
                if (player.health <= 0) continue;
                // ì–´ìŒ”ì‹  ì€ì‹ : ë‚´ê°€ ì•„ë‹Œ í”Œë ˆì´ì–´ì—ê²Œ ë³´ì´ì§€ ì•ŠìŒ
                if (!isMe && player.stealthed) continue;
                
                // ë‹¤ë¥¸ í”Œë ˆì´ì–´ëŠ” ë³´ê°„ ìœ„ì¹˜ ì‚¬ìš©, ë‚´ í”Œë ˆì´ì–´ëŠ” ì‹¤ì‹œê°„ ìœ„ì¹˜ ì‚¬ìš©
                const renderX = isMe ? player.x : (playerRenderPos[id] ? playerRenderPos[id].x : player.x);
                const renderY = isMe ? player.y : (playerRenderPos[id] ? playerRenderPos[id].y : player.y);
                const screenX = renderX - cameraX_r;
                const screenY = renderY - cameraY_r;
                
                if (screenX < -PLAYER_SIZE || screenX > canvas.width * _z + PLAYER_SIZE ||
                    screenY < -PLAYER_SIZE || screenY > canvas.height * _z + PLAYER_SIZE) {
                    continue;
                }
                
                // ê´€ì „ ëŒ€ìƒ ê°•ì¡° (ë…¸ë€ ì›)
                if (id === spectateTargetId) {
                    ctx.strokeStyle = 'rgba(255, 215, 0, 0.6)';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(screenX + PLAYER_SIZE / 2, screenY + PLAYER_SIZE / 2, PLAYER_SIZE / 2 + 8, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // ì–´ìŒ”ì‹  ì€ì‹  ì‹œ ë°˜íˆ¬ëª… ì²˜ë¦¬ (ìì‹ ì—ê²Œë§Œ)
                const stealthAlpha = (isMe && player.stealthed) ? 0.35 : 1.0;
                ctx.save();
                ctx.globalAlpha = stealthAlpha;

                // ì²´ë ¥ë°” (ê°œì„ )
                const hpBarW = PLAYER_SIZE + 20;
                const hpBarH = 8;
                const hpBarX = screenX + PLAYER_SIZE / 2 - hpBarW / 2;
                const hpBarY = screenY - 22;
                const healthPercent = Math.max(0, player.health / player.maxHealth);

                // HP ë°” (solid color â€” gradient ìƒì„± ë¹„ìš© ì œê±°)
                ctx.fillStyle = '#111';
                ctx.fillRect(hpBarX - 1, hpBarY - 1, hpBarW + 2, hpBarH + 2);
                ctx.fillStyle = '#1a0000';
                ctx.fillRect(hpBarX, hpBarY, hpBarW, hpBarH);
                ctx.fillStyle = healthPercent > 0.5 ? '#00e676' : healthPercent > 0.25 ? '#ff9800' : '#e53935';
                ctx.fillRect(hpBarX, hpBarY, hpBarW * healthPercent, hpBarH);
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 1;
                ctx.strokeRect(hpBarX, hpBarY, hpBarW, hpBarH);

                // â”€â”€ ì‚¬ë¬´ë¼ì´ ì°¨ì§• ê²Œì´ì§€ (ì²´ë ¥ë°” ë°”ë¡œ ìœ„, ë‹‰ë„¤ì„ ì•„ë˜) â”€â”€
                if (player.class === 'samurai' && player.samuraiCharging && player.samuraiChargeStart) {
                    const now2 = Date.now();
                    const chargedMs2 = Math.min(now2 - player.samuraiChargeStart, SAMURAI_MAX_CHARGE);
                    const chargeRatio2 = chargedMs2 / SAMURAI_MAX_CHARGE;
                    const cgW = hpBarW;
                    const cgH = 4;
                    const cgX = hpBarX;
                    const cgY = hpBarY - cgH - 3;
                    // ë°°ê²½
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    ctx.fillRect(cgX - 1, cgY - 1, cgW + 2, cgH + 2);
                    // ê²Œì´ì§€ (íŒŒâ†’ì£¼í™©â†’ë¶‰)
                    const r = Math.round(80 + 175 * chargeRatio2);
                    const g = Math.round(200 - 150 * chargeRatio2);
                    const b = Math.round(255 - 220 * chargeRatio2);
                    ctx.fillStyle = `rgb(${r},${g},${b})`;
                    ctx.shadowColor = `rgb(${r},${g},${b})`;
                    ctx.shadowBlur = 2;
                    ctx.fillRect(cgX, cgY, cgW * Math.max(0, Math.min(1, chargeRatio2)), cgH);
                    ctx.shadowBlur = 0;
                }

                // â”€â”€ ì›Œë¦¬ì–´ ì „íˆ¬íƒœì„¸ ê²Œì´ì§€ (ì²´ë ¥ë°” ë°”ë¡œ ìœ„) â”€â”€
                if (player.class === 'warrior' && player.warriorSkillActive) {
                    const now3 = Date.now();
                    // warriorSkillEndëŠ” ë¡œì»¬ì—ë§Œ ìˆìœ¼ë¯€ë¡œ ë‚´ í”Œë ˆì´ì–´ì¼ ë•Œë§Œ ì •í™•í•œ ì‹œê°„ í‘œì‹œ
                    // ë‹¤ë¥¸ í”Œë ˆì´ì–´ëŠ” active ì—¬ë¶€ë§Œ ì•Œ ìˆ˜ ìˆìœ¼ë¯€ë¡œ í’€ê²Œì´ì§€ë¡œ í‘œì‹œ
                    const isMyWarrior = (player === players[myPlayerId]);
                    const ratio = isMyWarrior
                        ? Math.max(0, Math.min(1, (warriorSkillEnd - now3) / 3000))
                        : 1;
                    const wgW = hpBarW;
                    const wgH = 4;
                    const wgX = hpBarX;
                    const wgY = hpBarY - wgH - 3;
                    // ë°°ê²½
                    ctx.fillStyle = 'rgba(0,0,0,0.5)';
                    ctx.fillRect(wgX - 1, wgY - 1, wgW + 2, wgH + 2);
                    // ê²Œì´ì§€ ìƒ‰: íšŒì „ë² ê¸° ì¤€ë¹„ ì¤‘ì´ë©´ ë°ì€ ê¸ˆìƒ‰, ì•„ë‹ˆë©´ ë¶‰ì€ìƒ‰
                    const isSpinReady = isMyWarrior && warriorSpinReady;
                    ctx.fillStyle = isSpinReady ? '#ffd700' : '#ff4444';
                    ctx.shadowColor = isSpinReady ? '#ffaa00' : '#ff0000';
                    ctx.shadowBlur = 3;
                    ctx.fillRect(wgX, wgY, wgW * ratio, wgH);
                    ctx.shadowBlur = 0;

                }

                
                // í”Œë ˆì´ì–´ ì›
                ctx.fillStyle = player.color;
                ctx.beginPath();
                ctx.arc(screenX + PLAYER_SIZE / 2, screenY + PLAYER_SIZE / 2, PLAYER_SIZE / 2, 0, Math.PI * 2);
                ctx.fill();
                
                // í…Œë‘ë¦¬
                ctx.strokeStyle = isMe ? '#FFD700' : '#fff';
                ctx.lineWidth = isMe ? 4 : 2;
                ctx.stroke();
                
                // ë‹‰ë„¤ì„ (ì²´ë ¥ë°”ë³´ë‹¤ ë” ìœ„)
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Malgun Gothic';
                ctx.textAlign = 'center';
                ctx.fillText(player.nickname, screenX + PLAYER_SIZE / 2, screenY - 34);

                // ëŒ€ì¥ì¥ì´ ê°•í™” ë ˆë²¨ í‘œì‹œ (ë‹‰ë„¤ì„ ìœ„)
                if (player.class === 'blacksmith' && player.smithEnhanceLevel > 0) {
                    ctx.save();
                    ctx.fillStyle = '#ffd700';
                    ctx.font = `bold 12px Malgun Gothic`;
                    ctx.textAlign = 'center';
                    ctx.shadowColor = '#ff8c00';
                    ctx.shadowBlur = 3;
                    ctx.fillText(`âš’ +${player.smithEnhanceLevel}ê°•`, screenX + PLAYER_SIZE / 2, screenY - 50);
                    ctx.restore();
                }

                // ì‚¬ë¬´ë¼ì´ íŒ¨ë§ ì˜¤ë¼
                if (player.samuraiParrying) {
                    const pulse = 0.4 + 0.3 * Math.sin(Date.now() / 60);
                    ctx.globalAlpha = pulse;
                    ctx.strokeStyle = '#00cfff';
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.arc(screenX + PLAYER_SIZE / 2, screenY + PLAYER_SIZE / 2, PLAYER_SIZE / 2 + 9, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = stealthAlpha;
                    ctx.fillStyle = '#00cfff';
                    ctx.font = 'bold 13px Malgun Gothic';
                    ctx.textAlign = 'center';
                    ctx.fillText('âš” íŒ¨ë§', screenX + PLAYER_SIZE / 2, screenY + PLAYER_SIZE + 35);
                }
                
                // ì›Œë¦¬ì–´ ìŠ¤í‚¬ ì˜¤ë¼
                if (player.warriorSkillActive) {
                    ctx.globalAlpha = 0.3 + 0.1 * Math.sin(Date.now() / 120);
                    ctx.strokeStyle = '#ff4444';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(screenX + PLAYER_SIZE / 2, screenY + PLAYER_SIZE / 2, PLAYER_SIZE / 2 + 6, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = stealthAlpha;
                }

                // ëŒ€ì¥ì¥ì´ ê°•í™” ê²½ì§ ì˜¤ë¼
                if (player.smithForging) {
                    ctx.globalAlpha = 0.5 + 0.2 * Math.sin(Date.now() / 80);
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.arc(screenX + PLAYER_SIZE / 2, screenY + PLAYER_SIZE / 2, PLAYER_SIZE / 2 + 8, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = stealthAlpha;
                    ctx.fillStyle = '#ffd700';
                    ctx.font = 'bold 13px Malgun Gothic';
                    ctx.textAlign = 'center';
                    ctx.fillText('âš’ ê°•í™” ì¤‘...', screenX + PLAYER_SIZE / 2, screenY + PLAYER_SIZE + 35);
                }

                // ë³¸ì¸ í‘œì‹œ
                if (isMe) {
                    ctx.fillStyle = '#FFD700';
                    ctx.font = 'bold 12px Malgun Gothic';
                    ctx.textAlign = 'center';
                    ctx.fillText('YOU', screenX + PLAYER_SIZE / 2, screenY + PLAYER_SIZE + 20);
                }

                // â”€â”€ ìŠ¤í  ì´í™íŠ¸ ì‹œê°í™” â”€â”€
                const spellSrc = isMe ? { spell: mySpell } : (player.spell ? { spell: player.spell } : null);
                // ëª¨ë˜ì‹œê³„ (í™©ê¸ˆ ê»ë°ê¸°) â€” ë³¸ì¸ë§Œ ë¡œì»¬ hourglassActive í‘œì‹œ (ë‹¤ë¥¸ í”Œë ˆì´ì–´ì—” ë¯¸í‘œì‹œ)
                const showHourglass = isMe ? hourglassActive : false;
                if (showHourglass) {
                    ctx.save();
                    const hgPulse = 0.6 + 0.4 * Math.sin(Date.now() / 120);
                    ctx.strokeStyle = `rgba(255,215,0,${hgPulse})`;
                    ctx.lineWidth = 4;
                    ctx.shadowColor = '#ffd700';
                    ctx.shadowBlur = 3;
                    ctx.beginPath();
                    ctx.arc(screenX + PLAYER_SIZE/2, screenY + PLAYER_SIZE/2, PLAYER_SIZE * 0.85, 0, Math.PI*2);
                    ctx.stroke();
                    ctx.fillStyle = `rgba(255,215,0,${hgPulse * 0.18})`;
                    ctx.fill();
                    ctx.font = 'bold 16px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.shadowBlur = 4;
                    ctx.fillStyle = '#ffd700';
                    ctx.fillText('âŒ›', screenX + PLAYER_SIZE/2, screenY - 8);
                    ctx.restore();
                }
                // ë¶„ë…¸ (ë¶‰ì€ ì˜¤ë¼)
                const showRage = isMe ? rageActive : player.rageActive;
                if (showRage) {
                    const rPulse = 0.4 + 0.3 * Math.sin(Date.now() / 80);
                    ctx.globalAlpha = rPulse + 0.3;
                    ctx.strokeStyle = '#ff3c00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(screenX + PLAYER_SIZE/2, screenY + PLAYER_SIZE/2, PLAYER_SIZE * 0.7 + rPulse*6, 0, Math.PI*2);
                    ctx.stroke();
                }
                // ìœ ì²´í™” (íŒŒë€ ì”ìƒ ë§)
                const showFluid = isMe ? fluidActive : player.fluidActive;
                if (showFluid) {
                    const fPulse = 0.3 + 0.3 * Math.sin(Date.now() / 100);
                    ctx.globalAlpha = fPulse + 0.3;
                    ctx.strokeStyle = '#44aaff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(screenX + PLAYER_SIZE/2, screenY + PLAYER_SIZE/2, PLAYER_SIZE * 0.75, 0, Math.PI*2);
                    ctx.stroke();
                }

                // ì–´ìŒ”ì‹  ì€ì‹  ë³µì›
                ctx.restore(); // stealthAlpha restore
            }

            // â”€â”€ ì–´ìŒ”ì‹  ì°Œë¥´ê¸° (ëª¨ë“  í”Œë ˆì´ì–´ playerStabs ê¸°ë°˜) â”€â”€
            ctx.strokeStyle = '#cc99ff';
            ctx.lineWidth = 3;
            for (const id in playerStabs) {
                const stab = playerStabs[id];
                const owner = players[id];
                if (owner && !owner.isMe && owner.stealthed && id !== myPlayerId) continue;
                const progress = 1 - stab.frames / stab.totalFrames;
                const stabLen = ASSASSIN_STAB_RANGE * Math.min(1, progress * 2);
                // í•­ìƒ ê³µê²© ì‹œì‘ ë‹¹ì‹œ ì €ì¥ëœ ìœ„ì¹˜(stab.x/y) ê¸°ì¤€ ë Œë”ë§
                const scx = stab.x - cameraX_r;
                const scy = stab.y - cameraY_r;
                ctx.beginPath();
                ctx.moveTo(scx, scy);
                ctx.lineTo(scx + Math.cos(stab.dir) * stabLen, scy + Math.sin(stab.dir) * stabLen);
                ctx.stroke();
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(scx + Math.cos(stab.dir) * stabLen, scy + Math.sin(stab.dir) * stabLen, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            // â”€â”€ ì–´ìŒ”ì‹  ì—°ê¸° íŒŒí‹°í´ (ë°°ì¹˜) â”€â”€
            ctx.fillStyle = '#aaaacc';
            for (const p of assassinSmokeParticles) {
                const sx = p.x - cameraX_r;
                const sy = p.y - cameraY_r;
                if (sx < -80 || sx > canvas.width + 80 || sy < -80 || sy > canvas.height + 80) continue;
                ctx.globalAlpha = Math.max(0, p.life * 0.55);
                ctx.beginPath();
                ctx.arc(sx, sy, Math.max(0.5, p.radius * p.life), 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // â”€â”€ ì›Œë¦¬ì–´ ê²€ íœ˜ë‘ë¥´ê¸° (ëª¨ë“  í”Œë ˆì´ì–´ playerSwings ê¸°ë°˜) â”€â”€
            for (const id in playerSwings) {
                const sw = playerSwings[id];
                const owner = players[id];
                if (!owner || owner.isSpectator || owner.health <= 0) continue;
                // ox/oy: ê³µê²© ì‹œì‘ ë‹¹ì‹œ ìœ„ì¹˜ ê¸°ì¤€ (ì—†ìœ¼ë©´ ë³´ê°„ ìœ„ì¹˜ fallback)
                const _rp_sw = playerRenderPos[id];
                const sx = (sw.ox !== undefined ? sw.ox : (_rp_sw ? _rp_sw.x : owner.x + PLAYER_SIZE / 2)) - cameraX_r;
                const sy = (sw.oy !== undefined ? sw.oy : (_rp_sw ? _rp_sw.y : owner.y + PLAYER_SIZE / 2)) - cameraY_r;
                const isSpinAtk = (sw.arc >= Math.PI * 1.9);
                const halfArc = sw.arc / 2;
                const progress = 1 - sw.frames / sw.totalFrames;

                ctx.save();
                ctx.globalAlpha = 0.88;
                ctx.strokeStyle = isSpinAtk ? '#ff6666' : '#e0e0ff';
                ctx.lineWidth = isSpinAtk ? 4 : 3;
                ctx.shadowColor = isSpinAtk ? '#ff2222' : '#aaaaff';
                ctx.shadowBlur = 2;

                // ê²€ í˜¸ (ì§€ë‚˜ì˜¨ ê¶¤ì )
                ctx.beginPath();
                ctx.arc(sx, sy, sw.range, sw.dir - halfArc, sw.dir - halfArc + sw.arc * progress);
                ctx.stroke();

                // ê²€ë‚  (í˜„ì¬ ìœ„ì¹˜)
                ctx.lineWidth = isSpinAtk ? 5 : 3;
                ctx.beginPath();
                ctx.moveTo(sx, sy);
                ctx.lineTo(sx + Math.cos(sw.angle) * sw.range, sy + Math.sin(sw.angle) * sw.range);
                ctx.stroke();
                ctx.restore();
            }
            
            // â”€â”€ ëŒ€ì¥ì¥ì´ ë§ì¹˜ ê³µê²© (ëª¨ë“  í”Œë ˆì´ì–´ playerHammers ê¸°ë°˜) â”€â”€
            for (const id in playerHammers) {
                const h = playerHammers[id];
                const owner = players[id];
                if (!owner || owner.isSpectator || owner.health <= 0) continue;
                // ê³µê²© ì‹œì‘ ë‹¹ì‹œ ì €ì¥ëœ ìœ„ì¹˜(h.x/y) ê¸°ì¤€ìœ¼ë¡œ ë Œë”ë§ (ì–´ê¸‹ë‚¨ ë°©ì§€)
                const _rp_h = playerRenderPos[id];
                const cx = (h.x !== undefined ? h.x : (_rp_h ? _rp_h.x : owner.x + PLAYER_SIZE / 2)) - cameraX_r;
                const cy = (h.y !== undefined ? h.y : (_rp_h ? _rp_h.y : owner.y + PLAYER_SIZE / 2)) - cameraY_r;

                const elapsed = h.totalFrames - h.frames;
                const progress = elapsed / h.totalFrames;
                const alpha = Math.max(0, 1 - progress * 1.2);
                const sqSize = SMITH_HAMMER_RANGE * 2;
                const offsetFront = PLAYER_SIZE / 2 + 4;

                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(h.dir);
                ctx.globalAlpha = alpha;

                ctx.fillStyle = 'rgba(230, 126, 34, 0.55)';
                ctx.shadowColor = '#ff8c00';
                ctx.shadowBlur = 3;
                ctx.fillRect(offsetFront, -sqSize / 2, sqSize, sqSize);

                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 2;
                ctx.strokeRect(offsetFront, -sqSize / 2, sqSize, sqSize);

                ctx.restore();
            }

            // â”€â”€ ì‚¬ë¬´ë¼ì´ ì°Œë¥´ê¸° / ë°˜ê²© ì´í™íŠ¸ â”€â”€
            for (const key in playerSamuraiSlashes) {
                const s = playerSamuraiSlashes[key];

                // â”€â”€ burstëŠ” owner ì²´í¬ ì—†ì´ ë…ë¦½ ë Œë”ë§ â”€â”€
                if (s.type === 'burst') {
                    const bprog = 1 - s.frames / s.totalFrames;
                    const bAlpha = Math.max(0, 0.88 - bprog * 0.95);
                    const bx = s.x - cameraX_r;
                    const by = s.y - cameraY_r;
                    const bRadius = s.radius;
                    ctx.save();
                    ctx.globalAlpha = bAlpha;
                    ctx.strokeStyle = '#ff6666';
                    ctx.lineWidth = 4;
                    ctx.shadowColor = '#ff2222';
                    ctx.shadowBlur = 2;
                    // í˜¸ (360ë„ ë² ê¸°ì²˜ëŸ¼ ì›í˜• ê¶¤ì )
                    ctx.beginPath();
                    ctx.arc(bx, by, bRadius, 0, Math.PI * 2 * bprog);
                    ctx.stroke();
                    // ê²€ë‚ ì„ 
                    ctx.lineWidth = 5;
                    ctx.beginPath();
                    ctx.moveTo(bx, by);
                    const bAngle = Math.PI * 2 * bprog;
                    ctx.lineTo(bx + Math.cos(bAngle) * bRadius, by + Math.sin(bAngle) * bRadius);
                    ctx.stroke();
                    // ë‚´ë¶€ ì—°í•œ ì±„ìš°ê¸°
                    ctx.globalAlpha = bAlpha * 0.10;
                    ctx.fillStyle = '#ff4444';
                    ctx.beginPath();
                    ctx.arc(bx, by, bRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    continue;
                }

                const owner = players[s.ownerId];
                if (!owner || owner.isSpectator || owner.health <= 0) continue;
                // ox/oy: ê³µê²© ì‹œì‘ ë‹¹ì‹œ ìœ„ì¹˜ ê¸°ì¤€ (ì—†ìœ¼ë©´ ë³´ê°„ ìœ„ì¹˜ fallback)
                const _rp_sl = playerRenderPos[s.ownerId];
                const sx = (s.ox !== undefined ? s.ox : (_rp_sl ? _rp_sl.x : owner.x + PLAYER_SIZE / 2)) - cameraX_r;
                const sy = (s.oy !== undefined ? s.oy : (_rp_sl ? _rp_sl.y : owner.y + PLAYER_SIZE / 2)) - cameraY_r;
                const progress = s.progress !== undefined ? s.progress : (1 - s.frames / (s.totalFrames || SAMURAI_SLASH_TOTAL));

                ctx.save();

                if (s.type === 'counter') {
                    // ë°˜ê²© ëŒì§„ â€” ê°•ë ¬í•œ ë¶‰ì€ ì”ìƒ
                    ctx.globalAlpha = Math.max(0, 0.75 - progress * 0.8);
                    ctx.strokeStyle = '#ff2244';
                    ctx.lineWidth = 6;
                    ctx.shadowColor = '#ff0033';
                    ctx.shadowBlur = 4;
                    ctx.beginPath();
                    ctx.moveTo(sx, sy);
                    ctx.lineTo(sx + Math.cos(s.dir + Math.PI) * 55, sy + Math.sin(s.dir + Math.PI) * 55);
                    ctx.stroke();
                } else {
                    // ì°Œë¥´ê¸° â€” ì‚¬ê°í˜• ê¶¤ì  (ì°¨ì§• ë ˆë²¨ë³„ í¬ê¸°)
                    const tLen = (s.thrustLength || 155) * progress;
                    const tW   = s.thrustWidth  || 28;
                    ctx.globalAlpha = 0.45;
                    ctx.fillStyle = '#aaddff';
                    ctx.shadowColor = '#6699ff';
                    ctx.shadowBlur = 5;
                    ctx.save();
                    ctx.translate(sx, sy);
                    ctx.rotate(s.dir);
                    ctx.fillRect(-PLAYER_SIZE, -tW / 2, tLen + PLAYER_SIZE, tW);
                    ctx.restore();
                }
                ctx.restore();
            }

            // íŒŒí‹°í´ (ëŒ€ì‰¬ ë¨¼ì§€/ì”ìƒ) â€” ë°°ì¹˜ ë Œë”ë§ (save/restore ì—†ì´)
            for (const p of particles) {
                const sx = p.x - cameraX_r;
                const sy = p.y - cameraY_r;
                if (sx < -50 || sx > canvas.width + 50 || sy < -50 || sy > canvas.height + 50) continue;
                ctx.globalAlpha = Math.max(0, p.life * 0.75);
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(sx, sy, Math.max(0.5, p.radius * p.life), 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // íˆíŠ¸ ì´í™íŠ¸ â€” ë°°ì¹˜ ë Œë”ë§
            for (const e of hitEffects) {
                const sx = e.x - cameraX_r;
                const sy = e.y - cameraY_r;
                if (sx < -50 || sx > canvas.width + 50 || sy < -50 || sy > canvas.height + 50) continue;
                ctx.globalAlpha = Math.max(0, e.life * 0.9);
                ctx.fillStyle = e.color;
                ctx.beginPath();
                ctx.arc(sx, sy, Math.max(0.5, e.radius * e.life), 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // í™”ë©´ í”Œë˜ì‹œ (í”¼ê²© ì‹œ)
            // (í™”ë©´ í”Œë˜ì‹œëŠ” HUD ì„¹ì…˜ìœ¼ë¡œ ì´ë™)

            // â”€â”€ ìŠ¤í  ë°œë™ ì´í™íŠ¸ (playerSpellEffects) ê·¸ë¦¬ê¸° â”€â”€
            for (const pid in playerSpellEffects) {
                const ef = playerSpellEffects[pid];
                const elapsed = Date.now() - ef.createdAt;
                if (elapsed > 600) { delete playerSpellEffects[pid]; continue; }
                const t = elapsed / 600;
                const sx = ef.x - cameraX_r;
                const sy = ef.y - cameraY_r;
                ctx.save();
                ctx.globalAlpha = Math.max(0, (1 - t) * 0.8);
                ctx.strokeStyle = ef.color || '#ffffff';
                ctx.lineWidth = 3;
                ctx.shadowColor = ef.color || '#ffffff';
                ctx.shadowBlur = 3;
                ctx.beginPath();
                ctx.arc(sx, sy, PLAYER_SIZE * (0.5 + t * 2), 0, Math.PI*2);
                ctx.stroke();
                ctx.restore();
            }

            // â”€â”€ ì£¼ëª½ í™”ì‚´ ì‹œê° ì´í™íŠ¸ (playerJumongArrows) ê·¸ë¦¬ê¸° â”€â”€
            ctx.strokeStyle = '#55ff88';
            ctx.lineWidth = 3;
            for (const id in playerJumongArrows) {
                const a = playerJumongArrows[id];
                if (!a || a.life <= 0) continue;
                let _aOffX = 0, _aOffY = 0;
                if (id !== myPlayerId) {
                    const _aOwner = players[id];
                    const _aRp = playerRenderPos[id];
                    if (_aOwner && _aRp) {
                        _aOffX = _aRp.x - (_aOwner.x + PLAYER_SIZE / 2);
                        _aOffY = _aRp.y - (_aOwner.y + PLAYER_SIZE / 2);
                    }
                }
                const ax = a.x + _aOffX - cameraX_r;
                const ay = a.y + _aOffY - cameraY_r;
                if (ax < -30 || ax > canvas.width * _z + 30 || ay < -30 || ay > canvas.height * _z + 30) continue;
                ctx.globalAlpha = Math.max(0, a.life);
                const aDir = a.dir || Math.atan2(a.vy, a.vx);
                ctx.beginPath();
                ctx.moveTo(ax - Math.cos(aDir) * 14, ay - Math.sin(aDir) * 14);
                ctx.lineTo(ax + Math.cos(aDir) * 14, ay + Math.sin(aDir) * 14);
                ctx.stroke();
                ctx.fillStyle = '#ccffdd';
                ctx.beginPath();
                ctx.arc(ax + Math.cos(aDir) * 14, ay + Math.sin(aDir) * 14, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // ì´ì•Œ ê·¸ë¦¬ê¸° â€” íƒ€ì…ë³„ ë°°ì¹˜ ë Œë”ë§ (save/restore ì œê±°)
            // ì¼ë°˜/ìŠ¤í‚¬ ì´ì•Œ ë¨¼ì €
            ctx.lineWidth = 2;
            for (let bullet of bullets) {
                if (bullet.isArrow || bullet.isPetal || bullet.isDummyBullet) continue;
                // ë‹¤ë¥¸ í”Œë ˆì´ì–´ê°€ ìœ ì´ì•Œ: ë°œì‚¬ì ìºë¦­í„°ì˜ ë Œë” ìœ„ì¹˜ì™€ ì‹¤ì œ ìœ„ì¹˜ ì°¨ì´ë§Œí¼ ë³´ì •
                // â†’ ì´ì•Œì´ í•­ìƒ ìºë¦­í„°ì—ì„œ ë‚˜ê°€ëŠ” ê²ƒì²˜ëŸ¼ ë³´ì„
                let _bOffX = 0, _bOffY = 0;
                if (bullet.ownerId !== myPlayerId) {
                    const _bOwner = players[bullet.ownerId];
                    const _bRp = playerRenderPos[bullet.ownerId];
                    if (_bOwner && _bRp) {
                        _bOffX = _bRp.x - (_bOwner.x + PLAYER_SIZE / 2);
                        _bOffY = _bRp.y - (_bOwner.y + PLAYER_SIZE / 2);
                    }
                }
                const screenX = bullet.x + _bOffX - cameraX_r;
                const screenY = bullet.y + _bOffY - cameraY_r;
                if (screenX < -20 || screenX > canvas.width * _z + 20 || screenY < -20 || screenY > canvas.height * _z + 20) continue;
                if (bullet.isSkillBullet) {
                    ctx.fillStyle = '#ff3333';
                    ctx.strokeStyle = '#ff8888';
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                } else {
                    ctx.fillStyle = '#ffe600';
                    ctx.strokeStyle = '#fff176';
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                }
            }
            // ë¬´í¬ ë²šê½ƒ ë¹„ìˆ˜
            ctx.fillStyle = '#ff88cc';
            ctx.strokeStyle = '#ffbbee';
            ctx.lineWidth = 1.5;
            for (let bullet of bullets) {
                if (!bullet.isPetal) continue;
                let _pOffX = 0, _pOffY = 0;
                if (bullet.ownerId !== myPlayerId) {
                    const _pOwner = players[bullet.ownerId];
                    const _pRp = playerRenderPos[bullet.ownerId];
                    if (_pOwner && _pRp) {
                        _pOffX = _pRp.x - (_pOwner.x + PLAYER_SIZE / 2);
                        _pOffY = _pRp.y - (_pOwner.y + PLAYER_SIZE / 2);
                    }
                }
                const screenX = bullet.x + _pOffX - cameraX_r;
                const screenY = bullet.y + _pOffY - cameraY_r;
                if (screenX < -20 || screenX > canvas.width * _z + 20 || screenY < -20 || screenY > canvas.height * _z + 20) continue;
                ctx.beginPath();
                ctx.arc(screenX, screenY, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }
            // ì£¼ëª½ í™”ì‚´
            ctx.strokeStyle = '#55ff88';
            ctx.lineWidth = 3;
            for (let bullet of bullets) {
                if (!bullet.isArrow) continue;
                const screenX = bullet.x - cameraX_r;
                const screenY = bullet.y - cameraY_r;
                if (screenX < -30 || screenX > canvas.width * _z + 30 || screenY < -30 || screenY > canvas.height * _z + 30) continue;
                const aDir = bullet.angle || Math.atan2(bullet.vy, bullet.vx);
                ctx.beginPath();
                ctx.moveTo(screenX - Math.cos(aDir) * 14, screenY - Math.sin(aDir) * 14);
                ctx.lineTo(screenX + Math.cos(aDir) * 14, screenY + Math.sin(aDir) * 14);
                ctx.stroke();
            }
            // í—ˆìˆ˜ì•„ë¹„ ì´ì•Œ
            ctx.fillStyle = '#88aaff';
            ctx.strokeStyle = '#aaccff';
            ctx.lineWidth = 2;
            for (let bullet of bullets) {
                if (!bullet.isDummyBullet) continue;
                const screenX = bullet.x - cameraX_r;
                const screenY = bullet.y - cameraY_r;
                if (screenX < -20 || screenX > canvas.width * _z + 20 || screenY < -20 || screenY > canvas.height * _z + 20) continue;
                ctx.beginPath();
                ctx.arc(screenX, screenY, 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }
            
            // (ì¡°ì¤€ì„ ì€ HUD ì„¹ì…˜ì—ì„œ ê·¸ë¦¼)

            // (ê´€ì „ UIëŠ” HUD ì„¹ì…˜ìœ¼ë¡œ ì´ë™)

            // â”€â”€ ì—°ìŠµ ëª¨ë“œ: í—ˆìˆ˜ì•„ë¹„ DPS íŒ¨ë„ â”€â”€
            if (gameMode === GAME_MODE.PRACTICE && players[DUMMY_ID]) {
                const dummy = players[DUMMY_ID];
                const dsx = dummy.x + PLAYER_SIZE / 2 - cameraX_r;
                const dsy = dummy.y + PLAYER_SIZE / 2 - cameraY_r;

                // í”Œë¡œíŒ… ë°ë¯¸ì§€ ìˆ«ì
                for (const fn of dummyFloatingNums) {
                    const fx = fn.x - cameraX_r;
                    const fy = fn.y - cameraY_r;
                    ctx.save();
                    ctx.globalAlpha = Math.max(0, fn.life);
                    ctx.font = `bold ${14 + Math.floor(fn.dmg / 10)}px Malgun Gothic`;
                    ctx.fillStyle = fn.dmg >= 30 ? '#ff4444' : '#ffdd44';
                    ctx.shadowColor = fn.dmg >= 30 ? '#ff0000' : '#ffaa00';
                    ctx.shadowBlur = 3;
                    ctx.textAlign = 'center';
                    ctx.fillText('-' + fn.dmg, fx, fy);
                    ctx.restore();
                }

                // ì¸¡ì • íŒ¨ë„ (í—ˆìˆ˜ì•„ë¹„ ì˜¤ë¥¸ìª½)
                const panelX = dsx + PLAYER_SIZE + 10;
                const panelY = dsy - 75;
                const panelW = 160;
                const panelH = 115;

                ctx.save();
                ctx.fillStyle = 'rgba(0,0,0,0.75)';
                ctx.strokeStyle = '#ff8844';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.roundRect(panelX, panelY, panelW, panelH, 8);
                ctx.fill();
                ctx.stroke();

                ctx.font = 'bold 13px Malgun Gothic';
                ctx.textAlign = 'left';

                ctx.fillStyle = '#ffaa44';
                ctx.fillText('ğŸ“Š ì „íˆ¬ ì¸¡ì •', panelX + 10, panelY + 20);

                ctx.fillStyle = '#fff';
                ctx.font = '13px Malgun Gothic';
                ctx.fillText('ëˆ„ì  í”¼í•´:', panelX + 10, panelY + 42);
                ctx.fillStyle = '#ff6666';
                ctx.font = 'bold 14px Malgun Gothic';
                ctx.fillText(dummyDmgTotal.toLocaleString(), panelX + 95, panelY + 42);

                ctx.fillStyle = '#fff';
                ctx.font = '13px Malgun Gothic';
                ctx.fillText('DPS:', panelX + 10, panelY + 66);
                const dpsColor = dummyDps > 100 ? '#ff4444' : dummyDps > 50 ? '#ffaa44' : '#44ff88';
                ctx.fillStyle = dpsColor;
                ctx.font = 'bold 15px Malgun Gothic';
                ctx.fillText(Math.round(dummyDps), panelX + 95, panelY + 66);

                ctx.fillStyle = '#fff';
                ctx.font = '13px Malgun Gothic';
                ctx.fillText('ë§ˆì§€ë§‰ í”¼í•´:', panelX + 10, panelY + 90);
                ctx.fillStyle = dummyLastHit >= 30 ? '#ff4444' : '#ffdd44';
                ctx.font = 'bold 14px Malgun Gothic';
                ctx.fillText(dummyLastHit > 0 ? dummyLastHit : '-', panelX + 95, panelY + 90);

                // ë¦¬ì…‹ íŒíŠ¸
                ctx.fillStyle = '#888';
                ctx.font = '11px Malgun Gothic';
                ctx.fillText('[Tab] ì¸¡ì • ì´ˆê¸°í™”', panelX + 10, panelY + 108);

                ctx.restore();
            }



            // ê²Œì„ ì”¬ ctx.save() ë‹«ê¸° (ì´í›„ëŠ” ëª¨ë‘ í™”ë©´ ì¢Œí‘œ HUD)
            ctx.restore();

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // HUD ì„¹ì…˜ (ctx.scale í•´ì œ í›„, í•­ìƒ í™”ë©´ ì¢Œí‘œ)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // â”€â”€ í™”ë©´ í”Œë˜ì‹œ â”€â”€
            if (screenFlashColor && Date.now() < screenFlashEnd) {
                ctx.fillStyle = screenFlashColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else {
                screenFlashColor = null;
            }

            // â”€â”€ ì¡°ì¤€ì„  (í™”ë©´ ì¢Œí‘œ ê¸°ì¤€) â”€â”€
            if (myPlayerId && players[myPlayerId] && !isSpectating && isAlive) {
                ctx.save();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(mouseX - 10, mouseY);
                ctx.lineTo(mouseX + 10, mouseY);
                ctx.moveTo(mouseX, mouseY - 10);
                ctx.lineTo(mouseX, mouseY + 10);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(mouseX, mouseY, 8, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            // â”€â”€ Rí‚¤ ê°•ì œ ì¢…ë£Œ ì§„í–‰ ë°” â”€â”€
            if (rKeyHolding && forceStopProgress > 0) {
                const barWidth = 300;
                const barHeight = 24;
                const barX = canvas.width / 2 - barWidth / 2;
                const barY = canvas.height - 60;
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(barX - 5, barY - 5, barWidth + 10, barHeight + 10);
                ctx.fillStyle = '#ff4444';
                ctx.fillRect(barX, barY, barWidth * (forceStopProgress / 100), barHeight);
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 2;
                ctx.strokeRect(barX, barY, barWidth, barHeight);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Malgun Gothic';
                ctx.textAlign = 'center';
                ctx.fillText(`âš  ê²Œì„ ê°•ì œ ì¢…ë£Œ ì¤‘... ${Math.ceil(3 - (forceStopProgress / 100) * 3)}ì´ˆ`, canvas.width / 2, barY + 17);
            }

            // â”€â”€ ê´€ì „ UI â”€â”€
            if (isSpectating || !isAlive) {
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.55)';
                ctx.fillRect(0, 0, canvas.width, 50);
                ctx.fillStyle = '#00fff5';
                ctx.font = 'bold 18px Malgun Gothic';
                ctx.textAlign = 'center';
                if (spectateTargetId && players[spectateTargetId]) {
                    ctx.fillText(`ğŸ‘ ê´€ì „ ì¤‘: ${players[spectateTargetId].nickname}`, canvas.width / 2, 32);
                } else {
                    ctx.fillStyle = '#aaa';
                    ctx.fillText('ğŸ‘ ê´€ì „ ì¤‘ â€” ì‚´ì•„ìˆëŠ” í”Œë ˆì´ì–´ ì—†ìŒ', canvas.width / 2, 32);
                }
                ctx.restore();
            }

            // â”€â”€ ì£¼ëª½ í˜¸í¬ì•„ì´ HUD â”€â”€
            if (myClass === 'jumong' && jumongHawkeyeActive) {
                const remaining = Math.max(0, jumongHawkeyeEnd - Date.now());
                ctx.save();
                ctx.strokeStyle = 'rgba(0,255,80,0.4)';
                ctx.lineWidth = 5;
                ctx.shadowColor = '#00ff44';
                ctx.shadowBlur = 7;
                ctx.strokeRect(3, 3, canvas.width - 6, canvas.height - 6);
                ctx.fillStyle = '#88ffaa';
                ctx.font = 'bold 15px Malgun Gothic';
                ctx.textAlign = 'left';
                ctx.shadowBlur = 3;
                ctx.fillText(`ğŸ¦… í˜¸í¬ì•„ì´ ${(remaining/1000).toFixed(1)}s`, 16, 70);
                ctx.restore();
            }
        }

        let _lastPlayerListUpdate = 0;
        function updatePlayerList() {
            const now = Date.now();
            if (now - _lastPlayerListUpdate < 500) return; // 2fps max for player list
            _lastPlayerListUpdate = now;
            const playerCount = Object.keys(players).length;
            document.getElementById('playerCount').textContent = playerCount;
            
            const listContent = document.getElementById('playerListContent');
            listContent.innerHTML = '';
            
            for (let id in players) {
                const player = players[id];
                const isMe = id === myPlayerId;
                
                const item = document.createElement('div');
                item.className = 'player-item';
                item.innerHTML = `
                    <div class="player-color" style="background: ${player.color}"></div>
                    <div>
                        <div><strong>${player.nickname}</strong> ${isMe ? '(ë‚˜)' : ''}</div>
                        <div style="font-size: 12px; color: #aaa;">${player.className}</div>
                    </div>
                `;
                listContent.appendChild(item);
            }
        }
    </script>
</body>
</html>
